From 203a753d8f85027be3a2639800aa54ac4cbc69a4 Mon Sep 17 00:00:00 2001
From: Joosep Pata <joosep.pata@cern.ch>
Date: Tue, 21 Oct 2014 13:18:28 +0300
Subject: [PATCH] added missing files

---
 DataFormats/JetReco/interface/HTTTopJetTagInfo.h   |  73 +++
 DataFormats/JetReco/src/classes_4.h                |  15 +-
 DataFormats/JetReco/src/classes_def_4.xml          |  17 +
 RecoJets/JetAlgorithms/interface/HEPTopTagger.h    | 527 ++++++---------------
 .../JetAlgorithms/interface/HEPTopTaggerWrapper.h  | 192 +++++---
 .../JetAlgorithms/interface/MultiRHEPTopTagger.h   |  91 ++++
 .../interface/MultiRHEPTopTaggerWrapper.h          | 210 ++++++++
 RecoJets/JetAlgorithms/src/HEPTopTagger.cc         | 350 ++++++++++++++
 RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc  |  73 +--
 RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc   | 132 ++++++
 .../JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc | 116 +++++
 RecoJets/JetProducers/plugins/CATopJetProducer.cc  |  12 +-
 RecoJets/JetProducers/plugins/CATopJetProducer.h   |   2 -
 RecoJets/JetProducers/plugins/HTTTopJetProducer.cc | 251 ++++++++++
 RecoJets/JetProducers/plugins/HTTTopJetProducer.h  | 140 ++++++
 .../JetProducers/plugins/VirtualJetProducer.cc     |  13 +-
 RecoJets/JetProducers/plugins/VirtualJetProducer.h |  10 +-
 17 files changed, 1718 insertions(+), 506 deletions(-)
 create mode 100644 DataFormats/JetReco/interface/HTTTopJetTagInfo.h
 create mode 100644 RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
 create mode 100644 RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
 create mode 100644 RecoJets/JetAlgorithms/src/HEPTopTagger.cc
 create mode 100644 RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
 create mode 100644 RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
 create mode 100644 RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
 create mode 100644 RecoJets/JetProducers/plugins/HTTTopJetProducer.h

diff --git a/DataFormats/JetReco/interface/HTTTopJetTagInfo.h b/DataFormats/JetReco/interface/HTTTopJetTagInfo.h
new file mode 100644
index 0000000..98f133e
--- /dev/null
+++ b/DataFormats/JetReco/interface/HTTTopJetTagInfo.h
@@ -0,0 +1,73 @@
+#ifndef AnalysisDataFormats_TopObjects_interface_HTTTopJetTagInfo_h
+#define AnalysisDataFormats_TopObjects_interface_HTTTopJetTagInfo_h
+
+
+// \class HTTTopJetTagInfo
+// 
+// \short specific tag info for HEPTopTagger tagging algorithm
+// HTTTopJetTagInfo is a class to hold the discriminator variables for the
+// HEPTopTagger algorithm.
+// 
+//
+// \author Gregor Kasieczka (based on  CATopJetTagInfo by Salvatore Rappoccio)
+// \version first version on 25 Sep 2014
+
+#include "DataFormats/BTauReco/interface/RefMacros.h"
+#include "DataFormats/BTauReco/interface/JetTagInfo.h"
+#include "DataFormats/BTauReco/interface/TaggingVariable.h"
+#include <vector>
+
+namespace reco {
+ 
+class HTTTopJetProperties {
+public:
+  HTTTopJetProperties() {
+    topMass          = 0.;
+    unfilteredMass   = 0.;
+    prunedMass	     = 0.;
+    fW		     = 0.;
+    massRatioPassed  = 0.;
+    isMultiR	     = 0;
+    Rmin	     = 0.;
+    RminExpected     = 0.;
+  }
+  double              topMass;         //<! Mass of the HTT top quark candidate [GeV] (at R=Rmin for MultiR)
+  double              unfilteredMass;  //<! Unfiltered mass of the triplet [GeV] (at R=Rmin for MultiR)
+  double              prunedMass;      //<! Mass of the pruned fat jet [GeV] (at R=Rmin for MultiR)
+  double              fW;              //<! Minimum distance of m_ij/m_123 from m_W/m_top (at R=Rmin for MultiR)
+  double              massRatioPassed; //<! Did the candidate pass the default mass ratio? Can be used instead of fW (at R=Rmin for MultiR)
+  bool                isMultiR;        //<! Tagger operated in MultiR mode
+  double              Rmin;            //<! R_min found in MultiR procedure. Set to -1 for non-MultiR mode.
+  double              RminExpected;    //<! R_min expected for a top quark based on filtered fat-jet pT. Set to -1 for non-MultiR mode.
+};
+
+ class HTTTopJetTagInfo : public JetTagInfo {
+public:
+  typedef edm::RefToBase<Jet> jet_type;
+  typedef HTTTopJetProperties  properties_type;
+    
+    HTTTopJetTagInfo(void) {}
+
+    virtual ~HTTTopJetTagInfo(void) {}
+  
+    virtual HTTTopJetTagInfo* clone(void) const { return new HTTTopJetTagInfo(*this); }
+    
+    const properties_type & properties() const {
+      return properties_;
+    }
+
+    void insert(const edm::RefToBase<Jet> & jet, const HTTTopJetProperties & properties) {
+      setJetRef(jet);
+      properties_ = properties;
+    }
+
+protected:
+    properties_type properties_;
+
+};
+
+DECLARE_EDM_REFS( HTTTopJetTagInfo )
+
+}
+
+#endif // AnalysisDataFormats_TopObjects_interface_HTTTopJetTagInfo_h
diff --git a/DataFormats/JetReco/src/classes_4.h b/DataFormats/JetReco/src/classes_4.h
index 1de6d02..9567f13 100644
--- a/DataFormats/JetReco/src/classes_4.h
+++ b/DataFormats/JetReco/src/classes_4.h
@@ -37,6 +37,7 @@
 #include "DataFormats/Common/interface/Ptr.h"
 
 #include "DataFormats/JetReco/interface/CATopJetTagInfo.h"
+#include "DataFormats/JetReco/interface/HTTTopJetTagInfo.h"
 
 namespace DataFormats_JetReco {
   struct dictionary4 {
@@ -178,7 +179,6 @@ namespace DataFormats_JetReco {
     edm::Wrapper<edm::Association<reco::FFTCaloJetCollection> > w_a_gj_fft_2;
 
 
-
     reco::CATopJetProperties                                            catopjetp;
     std::pair<edm::RefToBase<reco::Jet>, reco::CATopJetProperties>      catopjetp_p;
 
@@ -191,6 +191,19 @@ namespace DataFormats_JetReco {
     edm::reftobase::Holder<reco::BaseTagInfo, reco::CATopJetTagInfoRef> rb_catopjet;
     edm::reftobase::RefHolder<reco::CATopJetTagInfoRef>                 rbh_catopjet; 
 
+
+    reco::HTTTopJetProperties                                            htttopjetp;
+    std::pair<edm::RefToBase<reco::Jet>, reco::HTTTopJetProperties>      htttopjetp_p;
+
+    reco::HTTTopJetTagInfo                                               htttopjet;
+    reco::HTTTopJetTagInfoCollection                                     htttopjet_c;
+    reco::HTTTopJetTagInfoRef                                            htttopjet_r;
+    reco::HTTTopJetTagInfoRefProd                                        htttopjet_rp;
+    reco::HTTTopJetTagInfoRefVector                                      htttopjet_rv;
+    edm::Wrapper<reco::HTTTopJetTagInfoCollection>                       htttopjet_wc;
+    edm::reftobase::Holder<reco::BaseTagInfo, reco::HTTTopJetTagInfoRef> rb_htttopjet;
+    edm::reftobase::RefHolder<reco::HTTTopJetTagInfoRef>                 rbh_htttopjet; 
+
   };
 }
 #endif
diff --git a/DataFormats/JetReco/src/classes_def_4.xml b/DataFormats/JetReco/src/classes_def_4.xml
index dc60276..ef0d750 100644
--- a/DataFormats/JetReco/src/classes_def_4.xml
+++ b/DataFormats/JetReco/src/classes_def_4.xml
@@ -155,4 +155,21 @@
   <class name="edm::reftobase::Holder<reco::BaseTagInfo, reco::CATopJetTagInfoRef>" />
   <class name="edm::reftobase::RefHolder<reco::CATopJetTagInfoRef>" />
 
+
+  <class name="reco::HTTTopJetProperties" ClassVersion="11">
+   <version ClassVersion="11" checksum="1763149559"/>
+  </class>
+  <class name="std::pair<edm::RefToBase<reco::Jet>, reco::HTTTopJetProperties>"/>
+ 
+  <class name="reco::HTTTopJetTagInfo" ClassVersion="10">
+   <version ClassVersion="10" checksum="1184606281"/>
+  </class>
+  <class name="reco::HTTTopJetTagInfoCollection"/>
+  <class name="reco::HTTTopJetTagInfoRef"/>
+  <class name="reco::HTTTopJetTagInfoRefProd"/>
+  <class name="reco::HTTTopJetTagInfoRefVector"/>
+  <class name="edm::Wrapper<reco::HTTTopJetTagInfoCollection>"/>
+  <class name="edm::reftobase::Holder<reco::BaseTagInfo, reco::HTTTopJetTagInfoRef>" />
+  <class name="edm::reftobase::RefHolder<reco::HTTTopJetTagInfoRef>" />
+
 </lcgdict>
diff --git a/RecoJets/JetAlgorithms/interface/HEPTopTagger.h b/RecoJets/JetAlgorithms/interface/HEPTopTagger.h
index f84e14f..c66a79b 100644
--- a/RecoJets/JetAlgorithms/interface/HEPTopTagger.h
+++ b/RecoJets/JetAlgorithms/interface/HEPTopTagger.h
@@ -1,385 +1,142 @@
-#ifndef __HEPTOPTAGGER_HH__
-#define __HEPTOPTAGGER_HH__
-
-class HEPTopTagger {
-public:
-
-  typedef fastjet::ClusterSequence ClusterSequence;
-  typedef fastjet::JetAlgorithm JetAlgorithm;
-  typedef fastjet::JetDefinition JetDefinition;
-  typedef fastjet::PseudoJet PseudoJet;
-
-  HEPTopTagger(const fastjet::ClusterSequence & cs,
-	       const fastjet::PseudoJet & jet);
-
-  HEPTopTagger(const fastjet::ClusterSequence & cs,
-	       const fastjet::PseudoJet & jet,
-	       double mtmass, double mwmass);
-
-  void run_tagger();
-  bool is_maybe_top() const {return _is_maybe_top;}
-  bool is_masscut_passed() const {return _is_masscut_passed;}
-  const PseudoJet & top_candidate() const {return _top_candidate;}
-  const std::vector<PseudoJet> & top_subjets() const {return _top_subjets;}
-  const std::vector<PseudoJet> & top_hadrons() const {return _top_hadrons;}
-  unsigned top_count() const {return _top_count;}
-  const std::vector<PseudoJet> & hardparts() const {return _top_parts;}
-  unsigned parts_size() const {return _parts_size;}
-  double delta_top() const {return _delta_top;}
-  const std::vector<std::vector<PseudoJet> > & candjets() const {return _candjets;}
-  void get_setting() const;
-  void get_info() const;
-  // for setting parameters
-  void set_max_subjet_mass(double x) {_max_subjet_mass=x;}
-  void set_mass_drop_threshold(double x) {_mass_drop_threshold=x;}
-  void set_top_range(double xmin, double xmax) {_mtmin=xmin; _mtmax=xmax;}
-  void set_mass_ratio_range(double rmin, double rmax) {_rmin=rmin; _rmax=rmax;}
-  void set_mass_ratio_cut(double m23cut, double m13cutmin,double m13cutmax){_m23cut=m23cut; _m13cutmin=m13cutmin; _m13cutmax=m13cutmax;}
-  void set_nfilt(unsigned nfilt) {_nfilt=nfilt;}
-  void set_filtering_jetalgorithm(JetAlgorithm jet_algorithm) {_jet_algorithm=jet_algorithm;}
-  void set_reclustering_jetalgorithm(JetAlgorithm jet_algorithm) {_jet_algorithm_recluster=jet_algorithm;}
-  // 
-  double cos_theta_h() const;
-  double dr_bjj() const;
-  std::vector<double> dr_values() const;
-
-private:
-  const ClusterSequence * _cs;
-  const PseudoJet _jet;
-  const double _mtmass, _mwmass;
-  double _mass_drop_threshold;
-  double _max_subjet_mass; // stop when subjet mass < 30 GeV
-  double _mtmin, _mtmax;
-  double _rmin, _rmax;
-  double _m23cut, _m13cutmin, _m13cutmax;
-  size_t _nfilt;
-  // filtering algorithm
-  JetAlgorithm _jet_algorithm;
-  JetAlgorithm _jet_algorithm_recluster;
-  
-  bool _is_masscut_passed;
-  bool _is_maybe_top;
-  double _delta_top;
-  unsigned _top_count;
-  unsigned _parts_size;
-  PseudoJet _top_candidate;
-  std::vector<PseudoJet> _top_subjets;
-  std::vector<PseudoJet> _top_hadrons;
-  std::vector<PseudoJet> _top_parts;
-  std::vector<std::vector<PseudoJet> > _candjets;
-
-  void FindHardSubst(const PseudoJet& jet, std::vector<fastjet::PseudoJet>& t_parts);
-  std::vector<PseudoJet> Filtering(const std::vector <PseudoJet> & top_constits, const JetDefinition & filtering_def);
-  void store_topsubjets(const std::vector<PseudoJet>& top_subs);
-  bool check_mass_criteria(const std::vector<fastjet::PseudoJet> & top_subs) const;
-  double check_cos_theta(const PseudoJet & jet, const PseudoJet & subj1,const PseudoJet & subj2) const;
-  PseudoJet Sum(const std::vector<PseudoJet>& );
-  double r_max_3jets(const fastjet::PseudoJet & jet1,const fastjet::PseudoJet & jet2,
-		     const fastjet::PseudoJet & jet3) const;
-
-  bool debugg;
-
-};
-//--------------------------------------------------------------------
-double HEPTopTagger::cos_theta_h() const {
-  return check_cos_theta(_top_candidate,_top_subjets[1],_top_subjets[2]);// m23 is closest to mW
-}
-
-double HEPTopTagger::dr_bjj() const{
-  if(_top_subjets.size()!=3){return -1;}
-  return r_max_3jets(_top_subjets[0],_top_subjets[1],_top_subjets[2]);
-}
-
-std::vector<double> HEPTopTagger::dr_values() const{
-  std::vector<double> dr_values;
-  dr_values.push_back(sqrt(_top_subjets[1].squared_distance(_top_subjets[2])));
-  dr_values.push_back(sqrt(_top_subjets[0].squared_distance(_top_subjets[2])));
-  dr_values.push_back(sqrt(_top_subjets[0].squared_distance(_top_subjets[1])));
-  return dr_values;
-}
-
-
-double HEPTopTagger::r_max_3jets(const fastjet::PseudoJet & jet1,const fastjet::PseudoJet & jet2,const fastjet::PseudoJet & jet3) const{
-  fastjet::PseudoJet jet12,jet13,jet23;
-  jet12=jet1+jet2;
-  jet13=jet1+jet3;
-  jet23=jet2+jet3;
-
-  double a=sqrt(jet1.squared_distance(jet2));
-  double b=sqrt(jet2.squared_distance(jet3));
-  double c=sqrt(jet3.squared_distance(jet1));
-  double dR1=a,dR2=a;
-
-  if(a<=b && a<=c){
-    dR1=a;
-    dR2=sqrt(jet12.squared_distance(jet3));
-  };
-  if(b<a && b<=c){
-    dR1=b;
-    dR2=sqrt(jet23.squared_distance(jet1));
-  };
-  if(c<a && c<b){
-    dR1=c;
-    dR2=sqrt(jet13.squared_distance(jet2));
-  };
-  return max(dR1,dR2);
-}
-
-double HEPTopTagger::check_cos_theta(const PseudoJet & jet,const PseudoJet & subj1,const PseudoJet & subj2) const
-{
-  // the two jets of interest: top and lower-pt prong of W
-  PseudoJet W2;
-  PseudoJet top = jet;
-  
-  if(subj1.perp2() < subj2.perp2())
-    {
-      W2 = subj1;
-    }
-  else
-    {
-      W2 = subj2;
-    }
-
-  // transform these jets into jets in the rest frame of the W
-  W2.unboost(subj1+subj2);
-  top.unboost(subj1+subj2);
-  
-  double csthet = (W2.px()*top.px() + W2.py()*top.py() + W2.pz()*top.pz())/sqrt(W2.modp2() * top.modp2());  
-  return(csthet);
-}
-
-void HEPTopTagger::FindHardSubst(const PseudoJet & this_jet, std::vector<fastjet::PseudoJet> & t_parts)
-{
-  PseudoJet parent1(0,0,0,0), parent2(0,0,0,0);
-  if (this_jet.m() < _max_subjet_mass || !_cs->has_parents(this_jet, parent1, parent2))
-    {
-      t_parts.push_back(this_jet);
-    }
-  else 
-    {
-      if (parent1.m() < parent2.m()) swap(parent1, parent2);
-      
-      FindHardSubst(parent1,t_parts);
-      
-      if (parent1.m() < _mass_drop_threshold * this_jet.m())
-	{
-	  FindHardSubst(parent2,t_parts);
-	}
-    }
-}
-
-void HEPTopTagger::store_topsubjets(const std::vector<PseudoJet>& top_subs){
-  _top_subjets.resize(0);
-  double m12=(top_subs[0]+top_subs[1]).m();
-  double m13=(top_subs[0]+top_subs[2]).m();
-  double m23=(top_subs[1]+top_subs[2]).m();
-  //double m123=(top_subs[0]+top_subs[1]+top_subs[2]).m();
-  double dm12=abs(m12-_mwmass);
-  double dm13=abs(m13-_mwmass);
-  double dm23=abs(m23-_mwmass);
-  //double dm_min=min(dm12,min(dm13,dm23));
-  if(dm23<=dm12 && dm23<=dm13){
-    _top_subjets.push_back(top_subs[0]); //supposed to be b
-    _top_subjets.push_back(top_subs[1]); //W-jet 1
-    _top_subjets.push_back(top_subs[2]); //W-jet 2		
-  }
-  else if(dm13<=dm12 && dm13<dm23){
-    _top_subjets.push_back(top_subs[1]); //supposed to be b
-    _top_subjets.push_back(top_subs[0]); //W-jet 1
-    _top_subjets.push_back(top_subs[2]); //W-jet 2
-  }
-  else if(dm12<dm23 && dm12<dm13){
-    _top_subjets.push_back(top_subs[2]); //supposed to be b
-    _top_subjets.push_back(top_subs[0]); //W-jet 1
-    _top_subjets.push_back(top_subs[1]); //W-jet 2
-  }
-  return;
-}
-
-bool HEPTopTagger::check_mass_criteria(const std::vector<PseudoJet> & top_subs) const{
-  bool is_passed=false;
-  double m12=(top_subs[0]+top_subs[1]).m();
-  double m13=(top_subs[0]+top_subs[2]).m();
-  double m23=(top_subs[1]+top_subs[2]).m();
-  double m123=(top_subs[0]+top_subs[1]+top_subs[2]).m();
-  if(
-     (atan(m13/m12)>_m13cutmin && _m13cutmax > atan(m13/m12)
-      && (m23/m123>_rmin && _rmax>m23/m123))
-     ||
-     (((m23/m123)*(m23/m123) < 1-_rmin*_rmin*(1+(m13/m12)*(m13/m12))) &&
-      ((m23/m123)*(m23/m123) > 1-_rmax*_rmax*(1+(m13/m12)*(m13/m12))) && 
-      (m23/m123 > _m23cut))
-     ||
-     (((m23/m123)*(m23/m123) < 1-_rmin*_rmin*(1+(m12/m13)*(m12/m13))) &&
-      ((m23/m123)*(m23/m123) > 1-_rmax*_rmax*(1+(m12/m13)*(m12/m13))) && 
-      (m23/m123 > _m23cut))
-     ){ 
-    is_passed=true;
-  }
-  return is_passed;
-}
-
-////////// Top-TAGGER: /////////////////////////////////////////////////////////////////
-HEPTopTagger::HEPTopTagger(const fastjet::ClusterSequence & cs,
-			   const fastjet::PseudoJet & jet) : 
-  _cs(&cs), _jet(jet), _mtmass(172.3), _mwmass(80.4), 
-  _mass_drop_threshold(0.8), _max_subjet_mass(30.),
-  _mtmin(172.3 - 25.),_mtmax(172.3 + 25.), _rmin(0.85*80.4/172.3),_rmax(1.15*80.4/172.3),
-  _m23cut(0.35),_m13cutmin(0.2),_m13cutmax(1.3),
-  _nfilt(5),_jet_algorithm(fastjet::cambridge_algorithm),_jet_algorithm_recluster(fastjet::cambridge_algorithm),
-  debugg(false)
-{}
-
-HEPTopTagger::HEPTopTagger(const fastjet::ClusterSequence & cs,
-			   const fastjet::PseudoJet & jet,
-			   double mtmass,double mwmass
-			   ) : 
-  _cs(&cs), _jet(jet), _mtmass(mtmass), _mwmass(mwmass), 
-  _mass_drop_threshold(0.8), _max_subjet_mass(30.),
-  _mtmin(mtmass - 25.),_mtmax(mtmass + 25.), _rmin(0.85*mwmass/mtmass),_rmax(1.15*mwmass/mtmass),
-  _m23cut(0.35),_m13cutmin(0.2),_m13cutmax(1.3),
-  _nfilt(5),_jet_algorithm(fastjet::cambridge_algorithm),_jet_algorithm_recluster(fastjet::cambridge_algorithm),
-  debugg(false)
-{}
-
-
-void HEPTopTagger::run_tagger()
-{
-  _delta_top=1000000000000.0;
-  _top_candidate.reset(0.,0.,0.,0.);
-  _top_count=0;
-  _parts_size=0;
-  _is_maybe_top=_is_masscut_passed=false;
-  _top_subjets.clear();
-  _top_hadrons.clear();
-  _top_parts.clear();
-
-  if(debugg)
-    {
-      cout << "mtmass in top_tagger: " << _mtmass << endl;
-      cout << "mwmass in top_tagger: " << _mwmass << endl;
-      cout << "jet input HEPTopTagger: " << endl;
-      //printjet(_jet);
-    }
-  
-  
-  // input this_jet, output _top_parts
-  FindHardSubst(_jet, _top_parts);
-  
-  // store hard substructure of the top candidate
-  _parts_size=_top_parts.size();
-  
-  // these events are not interesting 
-  if(_top_parts.size() < 3){return;}
-  
-  for(unsigned rr=0; rr<_top_parts.size(); rr++){
-    for(unsigned ll=rr+1; ll<_top_parts.size(); ll++){
-      for(unsigned kk=ll+1; kk<_top_parts.size(); kk++){
-	// define top_constituents candidate before filtering 	      
-	std::vector <PseudoJet> top_constits = _cs->constituents(_top_parts[rr]);
-	_cs->add_constituents(_top_parts[ll],top_constits);
-	_cs->add_constituents(_top_parts[kk],top_constits);	      
-
-	      // define Filtering: filt_top_R and jetdefinition 
-	double filt_top_R 
-	  = min(0.3,0.5*sqrt(min(_top_parts[kk].squared_distance(_top_parts[ll]),
-				 min(_top_parts[rr].squared_distance(_top_parts[ll]),
-				     _top_parts[kk].squared_distance(_top_parts[rr])))));
-	JetDefinition filtering_def(_jet_algorithm, filt_top_R);
-	std::vector<PseudoJet> top_constits_filtered = Filtering(top_constits,filtering_def);
-	PseudoJet topcandidate = Sum(top_constits_filtered);
-	if( topcandidate.m() < _mtmin || _mtmax < topcandidate.m() ) continue;
-	_top_count++;
-	// obtain 3 subjets
-	JetDefinition reclustering(_jet_algorithm_recluster, 3.14/2);
-	
-     //// **** NEXT 3 LINES EDITED CKV 12/2/12 **** (edit suggested by G. P. Salam)
-     ClusterSequence * cssubtop = new ClusterSequence(top_constits_filtered,reclustering);
-	std::vector <PseudoJet> top_subs = sorted_by_pt(cssubtop->exclusive_jets(3));	      
-	cssubtop->delete_self_when_unused();
-     //// **** END EDIT ***************************
-     
-     _candjets.push_back(top_subs); //
-	
-	// transfer infos of the positively identified top to the outer world 
-	double deltatop = abs(topcandidate.m() - _mtmass);
-	if(deltatop < _delta_top){	 
-	  _delta_top = deltatop;
-	  _is_maybe_top = true;
-	  _top_candidate = topcandidate;
-	  store_topsubjets(top_subs);
-	  _top_hadrons=top_constits_filtered;
-	  /////////////////////// check mass plane cut////////////////////////
-	  _is_masscut_passed=check_mass_criteria(top_subs);
-	}// end deltatop < _delta_top
-      }// end kk
-    }// end ll
-  }// end rr
-  return;
-}
-
-
-std::vector<fastjet::PseudoJet> HEPTopTagger::Filtering(const std::vector <PseudoJet> & top_constits, const JetDefinition & filtering_def)
-{
-  // perform filtering
-  fastjet::ClusterSequence cstopfilt( top_constits, filtering_def);
- 
-  // extract top subjets
-  std::vector<PseudoJet> filt_top_subjets = sorted_by_pt(cstopfilt.inclusive_jets());
-  
-  // take first n_topfilt subjets
-  std::vector<PseudoJet> top_constits_filtered;
-  for(unsigned ii = 0; ii<min(_nfilt, filt_top_subjets.size()) ; ii++)
-    {
-      cstopfilt.add_constituents(filt_top_subjets[ii],top_constits_filtered);
-    }
-  return top_constits_filtered;
-}
-
-
-fastjet::PseudoJet HEPTopTagger::Sum(const std::vector<PseudoJet> & vec_pjet)
-{
-  PseudoJet sum;
-  sum.reset(0.,0.,0.,0.);
-  for(unsigned i=0;i<vec_pjet.size();i++){
-    sum += vec_pjet.at(i);
-  }
-  return sum;
-}
-
-void HEPTopTagger::get_info() const
-{
-  cout << "maybe_top: " <<  _is_maybe_top << endl;
-  cout << "mascut_passed: " <<  _is_masscut_passed << endl;
-  cout << "top candidate mass:" <<  _top_candidate.m() << endl;
-  cout << "top candidate (pt, eta, phi): (" 
-       <<  _top_candidate.perp() << ","
-       <<  _top_candidate.eta() << ","
-       <<  _top_candidate.phi_std() << ")" << endl;
-  cout << "hadrons size: " <<  _top_hadrons.size() << endl;
-  cout << "topcount: " <<  _top_count << endl;
-  cout << "parts size: " <<  _parts_size << endl;
-  cout << "delta_top: " <<  _delta_top << endl;  
-  return;
-}
-
-
-void HEPTopTagger::get_setting() const
-{
-  cout << "top mass: " <<  _mtmass << endl;
-  cout << "W mass: " <<  _mwmass << endl;
-  cout << "top mass range: [" << _mtmin << ", " << _mtmax << "]" << endl;
-  cout << "W mass ratio range: [" << _rmin << ", " << _rmax << "] (["
-       <<_rmin*_mtmass/_mwmass<< "%, "<< _rmax*_mtmass/_mwmass << "%])"<< endl;
-  cout << "mass ratio cut: (m23cut, m13min, m13max)=(" 
-       << _m23cut << ", " << _m13cutmin << ", " << _m13cutmax << ")" << endl;
-  cout << "mass_drop_threshold: " << _mass_drop_threshold << endl;
-  cout << "max_subjet_mass: " << _max_subjet_mass << endl;
-  cout << "n_filtering: " << _nfilt << endl;
-  cout << "JetAlgorithm for filtering: "<< _jet_algorithm << endl;
-  cout << "JetAlgorithm for reclustering: "<< _jet_algorithm_recluster << endl;
-  return;
-}
-
-
-#endif // __HEPTOPTAGGER_HH__
+//HEPTopTagger: 
+// Modes:
+// 0 = EARLY_MASSRATIO_SORT_MASS (apply massratio, then sort by distance to true top mass)
+// 1 = LATE_MASSRATIO_SORT_MASS (sort by distance to true top mass, then apply mass-ratio. Old HTT)
+// 2 = EARLY_MASSRATIO_SORT_MODDJADE (apply massratio, then sort by modified d-jade)
+// 3 = LATE_MASSRATIO_SORT_MODDJADE (sort by modified d-jade, then apply mass-ratio)
+// 4 = TWO_STEP_FILTER (take three highest pT objects after unclustering and apply mass ratio)
+
+
+#ifndef __HEPTOPTAGGER_HH__
+#define __HEPTOPTAGGER_HH__
+
+#include <math.h>
+#include "fastjet/PseudoJet.hh"
+#include "fastjet/ClusterSequence.hh"
+#include "fastjet/tools/Pruner.hh"
+#include "fastjet/tools/Filter.hh"
+
+// Allow putting evertything into a separate namepsace
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+namespace external {
+
+
+class HEPTopTagger {
+
+public:
+
+  enum Mode {EARLY_MASSRATIO_SORT_MASS, 
+	     LATE_MASSRATIO_SORT_MASS, 
+	     EARLY_MASSRATIO_SORT_MODDJADE,
+	     LATE_MASSRATIO_SORT_MODDJADE,
+	     TWO_STEP_FILTER};
+
+  typedef fastjet::ClusterSequence ClusterSequence;
+  typedef fastjet::JetAlgorithm JetAlgorithm;
+  typedef fastjet::JetDefinition JetDefinition;
+  typedef fastjet::PseudoJet PseudoJet;
+
+  HEPTopTagger();
+  
+  HEPTopTagger(fastjet::PseudoJet jet);
+  
+  HEPTopTagger(fastjet::PseudoJet jet,
+	       double mtmass, double mwmass);
+
+  //run tagger
+  void run_tagger();
+  
+  //get information
+  bool is_maybe_top() const {return _is_maybe_top;}
+  bool is_masscut_passed() const {return _is_masscut_passed;}
+  bool is_minptcut_passed() const {return _is_ptmincut_passed;}
+  bool is_tagged() const {return (_is_masscut_passed && _is_ptmincut_passed);}
+  const PseudoJet & top_candidate() const {return _top_candidate;}
+  const std::vector<PseudoJet> & top_subjets() const {return _top_subjets;}
+  const std::vector<PseudoJet> & top_hadrons() const {return _top_hadrons;}
+  const std::vector<PseudoJet> & hardparts() const {return _top_parts;}
+  unsigned parts_size() const {return _parts_size;}
+  double delta_top() const {return _delta_top;}
+  double djsum() const {return _djsum;}
+  double pruned_mass() const {return _pruned_mass;}
+  double unfiltered_mass() const {return _unfiltered_mass;}
+  double fW();
+  void get_setting() const;
+  void get_info() const;
+  const PseudoJet & t() const {return _top_candidate;}
+  const PseudoJet & b() const {return _top_subjets[0];}
+  const PseudoJet & W() const {return _W;}
+  const PseudoJet & W1() const {return _top_subjets[1];}
+  const PseudoJet & W2() const {return _top_subjets[2];}
+  const PseudoJet & j1() const {return _top_subs[0];}
+  const PseudoJet & j2() const {return _top_subs[1];}
+  const PseudoJet & j3() const {return _top_subs[2];}
+  const PseudoJet & fat() {return _fat;}
+ 
+  //set parameters
+  void set_max_subjet_mass(double x) {_max_subjet_mass = x;}
+  void set_mass_drop_threshold(double x) {_mass_drop_threshold = x;}
+  void set_top_range(double xmin, double xmax) {_mtmin = xmin; _mtmax = xmax;}
+  void set_mass_ratio_range(double rmin, double rmax) {_rmin = rmin; _rmax = rmax;}
+  void set_mass_ratio_cut(double m23cut, double m13cutmin,double m13cutmax) {_m23cut = m23cut; _m13cutmin = m13cutmin; _m13cutmax = m13cutmax;}
+  void set_nfilt(unsigned nfilt) {_nfilt = nfilt;}
+  void set_Rfilt(double Rfilt) {_Rfilt = Rfilt;}
+  void set_filtering_jetalgorithm(JetAlgorithm jet_algorithm) {_jet_algorithm_filter = jet_algorithm;}
+  void set_reclustering_jetalgorithm(JetAlgorithm jet_algorithm) {_jet_algorithm_recluster = jet_algorithm;}
+  void set_pruner_cuts(double zcut, double rcut_factor) {_zcut = zcut; _rcut_factor = rcut_factor;}
+  void set_mode(int mode) {_mode = mode;}
+  void set_debug(bool debug) {_debug = debug;}
+  void set_minpt_tag(double x) {_minpt_tag = x;}
+  void set_minpt_subjet(double x) {_minpt_subjet = x;}
+  
+private:
+  const PseudoJet* _jet;
+  double _mtmass, _mwmass;
+  double _mass_drop_threshold;
+  double _max_subjet_mass;
+  double _mtmin, _mtmax;
+  double _rmin, _rmax;
+  double _m23cut, _m13cutmin, _m13cutmax;
+  size_t _nfilt;
+  double _Rfilt;
+  double _Rprun;
+  JetAlgorithm _jet_algorithm_filter;
+  JetAlgorithm _jet_algorithm_recluster;
+  double _zcut;
+  double _rcut_factor;
+  int _mode;
+  double _minpt_tag;
+  double _minpt_subjet;
+  bool _debug;
+  PseudoJet _fat;
+  
+  bool _is_masscut_passed;
+  bool _is_ptmincut_passed;
+  bool _is_maybe_top;
+  double _djsum;
+  double _delta_top;
+  double _pruned_mass;
+  double _unfiltered_mass;
+  double _fw;
+  unsigned _parts_size;
+  PseudoJet _top_candidate;
+  PseudoJet _W;
+  std::vector<PseudoJet> _top_subs;
+  std::vector<PseudoJet> _top_subjets;
+  std::vector<PseudoJet> _top_hadrons;
+  std::vector<PseudoJet> _top_parts;
+  static bool _first_time;
+
+  //internal functions
+  void FindHardSubst(const PseudoJet& jet, std::vector<fastjet::PseudoJet>& t_parts);
+  std::vector<PseudoJet> Filtering(const std::vector <PseudoJet> & top_constits, const JetDefinition & filtering_def);
+  void store_topsubjets(const std::vector<PseudoJet>& top_subs);
+  bool check_mass_criteria(const std::vector<fastjet::PseudoJet> & top_subs) const;
+  void print_banner();
+  double perp(const PseudoJet & vec, const fastjet::PseudoJet & ref);
+  double djademod (const fastjet::PseudoJet & subjet_i, const fastjet::PseudoJet & subjet_j, const fastjet::PseudoJet & ref);
+};
+//--------------------------------------------------------------------
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+};
+#endif // __HEPTOPTAGGER_HH__
diff --git a/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h b/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
index 858fe63..d324827 100644
--- a/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
+++ b/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
@@ -39,25 +39,39 @@ FASTJET_BEGIN_NAMESPACE
 ///
 /// The HEP top tagger produces information similar to the Johns Hopkins tagger.
 ///  Accordingly I simply reuse the JHTopTaggerStructure.
+
+// Removed legacy comments by CHRISTOPHER SILKWORTH
+
 class HEPTopTaggerStructure;
 
 
 class HEPTopTagger : public TopTaggerBase {
 public:
-  /// Sets two of the algorithm parameters
-  ///
-  /// \param mass_drop_threshold    A splitting is hard if 
-  ///                                max(subjet_m) < mass_drop_threshold * m_child
-  /// \param max_subjet_mass        The tagger attempts to split subjets until
-  ///                                remaining subjets have m_subjet < max_subjet_mass.
-  /// \param use_subjet_mass_cuts   Whether to impose the subjet mass cuts described
-  ///                                in arXiv:1006.2833 (default=false)
-  /// Default values are taken from the original HepTopTagger.hh code.
-  HEPTopTagger(double mass_drop_threshold=0.8, double max_subjet_mass=30.,
-               bool use_subjet_mass_cuts=false)
-    : _mass_drop_threshold(mass_drop_threshold),
-      _max_subjet_mass(max_subjet_mass),
-      _use_subjet_mass_cuts(use_subjet_mass_cuts)
+  HEPTopTagger(double minSubjetPt, 
+	       double minCandPt, 
+	       double subjetMass, 
+	       double muCut, 
+	       double filtR,
+	       int filtN,
+	       int mode, 
+	       double minCandMass, 
+	       double maxCandMass, 
+	       double massRatioWidth, 
+	       double minM23Cut, 
+	       double minM13Cut, 
+	       double maxM13Cut) : minSubjetPt_(minSubjetPt),
+    minCandPt_(minCandPt),
+    subjetMass_(subjetMass),
+    muCut_(muCut),
+    filtR_(filtR),
+    filtN_(filtN),
+    mode_(mode),
+    minCandMass_(minCandMass),
+    maxCandMass_(maxCandMass),
+    massRatioWidth_(massRatioWidth),
+    minM23Cut_(minM23Cut),
+    minM13Cut_(minM13Cut),
+    maxM13Cut_(maxM13Cut)   
   {}
 
   /// returns a textual description of the tagger
@@ -73,59 +87,66 @@ public:
   typedef HEPTopTaggerStructure StructureType;
 
 private:
-  double _mass_drop_threshold;
-  double _max_subjet_mass;
-  bool _use_subjet_mass_cuts; ///< whether to include the is_masscut_passed() test
-};
-
-
-/// Basically just a copy of JHTopTaggerStructure, but this way HEPTopTagger can
-/// be a friend.
-
-//BEGIN COMMENTING OUT BY CHRISTOPHER SILKWORTH
-/*
-class HEPTopTaggerStructure : public JHTopTaggerStructure {
-public:
-  HEPTopTaggerStructure(std::vector<PseudoJet> pieces,
-      const JetDefinition::Recombiner *recombiner = 0)
-    : JHTopTaggerStructure(pieces, recombiner) {}
-
-protected:
-  friend class HEPTopTagger;
+    double minSubjetPt_; // Minimal pT for subjets [GeV]
+    double minCandPt_;   // Minimal pT to return a candidate [GeV]
+ 
+    double subjetMass_; // Mass above which subjets are further unclustered
+    double muCut_; // Mass drop threshold
+    
+    double filtR_; // maximal filtering radius
+    int filtN_; // number of filtered subjets to use
+
+    // HEPTopTagger Mode
+    // 0: do 2d-plane, return candidate with delta m_top minimal
+    // 1: return candidate with delta m_top minimal IF passes 2d plane
+    // 2: do 2d-plane, return candidate with max dj_sum
+    // 3: return candidate with max dj_sum IF passes 2d plane
+    // 4: return candidate built from leading three subjets after unclustering IF passes 2d plane
+    // Note: Original HTT was mode==1    
+    int mode_; 
+
+    // Top Quark mass window in GeV
+    double minCandMass_;
+    double maxCandMass_;
+    
+    double massRatioWidth_; // One sided width of the A-shaped window around m_W/m_top in %
+    double minM23Cut_; // minimal value of m23/m123
+    double minM13Cut_; // minimal value of atan(m13/m12)
+    double maxM13Cut_; // maximal value of atan(m13/m12)
 };
-*/
-//END COMMENTING OUT
-
-//BEGIN ADDED BY CHRISTOPHER SILKWORTH
 
 
 class HEPTopTaggerStructure : public CompositeJetStructure, public TopTaggerBaseStructure {
  public:
    /// ctor with pieces initialisation
    HEPTopTaggerStructure(const std::vector<PseudoJet>& pieces_in,
-                  const JetDefinition::Recombiner *recombiner = 0) :
-      CompositeJetStructure(pieces_in, recombiner), _cos_theta_w(0.0),W_rec(recombiner), 
-      rW_()
-	{}
- 
-   /// returns the W subjet
-      inline PseudoJet const & W() const{ 
-         rW_ = join(_pieces[0], _pieces[1], *W_rec);
-         return rW_;
-      }
+                  const JetDefinition::Recombiner *recombiner = 0) : CompositeJetStructure(pieces_in, recombiner),
+    _top_mass(0.0),
+    _unfiltered_mass(0.0),
+    _pruned_mass(0.0),
+    _fW(-1.),
+    _mass_ratio_passed(-1),
+    W_rec(recombiner), 
+    rW_(){}
+  
+   // Return W subjet
+   inline PseudoJet const & W() const{ 
+     rW_ = join(_pieces[0], _pieces[1], *W_rec);
+     return rW_;
+   }
+     
+   // Return leading subjet in W
+   inline PseudoJet  W1() const{
+     assert(W().pieces().size()>0);
+     return W().pieces()[0];
+   }
+       
+   /// returns the second W subjet
+   inline PseudoJet W2() const{
+     assert(W().pieces().size()>1);
+     return W().pieces()[1];
+   }
  
-      
-      inline PseudoJet  W1() const{
-         assert(W().pieces().size()>0);
-         return W().pieces()[0];
-      }
-      
-      /// returns the second W subjet
-      inline PseudoJet W2() const{
-         assert(W().pieces().size()>1);
-         return W().pieces()[1];
-      }
-
 
    /// returns the non-W subjet
    /// It will have 1 or 2 pieces depending on whether the tagger has
@@ -134,20 +155,29 @@ class HEPTopTaggerStructure : public CompositeJetStructure, public TopTaggerBase
      return _pieces[2];
    }
  
-   /// returns the W helicity angle
-   inline double cos_theta_W() const {return _cos_theta_w;}
- 
- //  /// returns the original jet (before tagging)
- //  const PseudoJet & original() const {return _original_jet;}
+   /// returns the candidate mass
+   inline double top_mass() const {return _top_mass;}
 
- 
- 
+   /// returns the unfiltered mass
+   inline double unfiltered_mass() const {return _unfiltered_mass;}
+
+   /// returns the pruned mass
+   inline double pruned_mass() const {return _pruned_mass;}
+
+   /// returns fW
+   inline double fW() const {return _fW;}
+
+   /// returns if 2d-mass plane cuts were passed
+   inline double mass_ratio_passed() const {return _mass_ratio_passed;}
+    
  protected:
-      double _cos_theta_w; ///< the W helicity angle
+      double _top_mass;
+      double _unfiltered_mass;
+      double _pruned_mass;
+      double _fW;
+      int _mass_ratio_passed;
+
       const JetDefinition::Recombiner  * W_rec;
-   //PseudoJet _W;             ///< the tagged W
-   //PseudoJet _non_W;         ///< the remaining pieces
- //  PseudoJet _original_jet;  ///< the original jet (before tagging)
  
       mutable PseudoJet rW_;
 
@@ -156,17 +186,25 @@ class HEPTopTaggerStructure : public CompositeJetStructure, public TopTaggerBase
  };
 
 
-//END ADDED BY CHRISTOPHER SILKWORTH
-
-
 //------------------------------------------------------------------------
 // description of the tagger
 inline std::string HEPTopTagger::description() const{ 
+
   std::ostringstream oss;
-  oss << "HEPTopTagger with {max. subjet mass = " << _max_subjet_mass
-      << ", mass-drop threshold = " << _mass_drop_threshold
-      << ", and " << (_use_subjet_mass_cuts ? "using" : "not using") << " subjet mass cuts" << std::endl;
-  oss << description_of_selectors();
+  oss << "HEPTopTagger with: "
+      << "minSubjetPt = " << minSubjetPt_ 
+      << "minCandPt = " << minCandPt_ 
+      << "subjetMass = " << subjetMass_ 
+      << "muCut = " << muCut_ 
+      << "filtR = " << filtR_ 
+      << "filtN = " << filtN_     
+      << "mode = " << mode_ 
+      << "minCandMass = " << minCandMass_ 
+      << "maxCandMass = " << maxCandMass_ 
+      << "massRatioWidth = " << massRatioWidth_ 
+      << "minM23Cut = " << minM23Cut_ 
+      << "minM13Cut = " << minM13Cut_ 
+      << "maxM13Cut = " << maxM13Cut_ << std::endl;
   return oss.str();
 }
 
diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
new file mode 100644
index 0000000..9cb4475
--- /dev/null
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
@@ -0,0 +1,91 @@
+//Adapted Version based on the work of Gregor.
+
+#ifndef __MULTIR_TOPTAGGER_HH__
+#define __MULTIR_TOPTAGGER_HH__
+
+#include <vector>
+#include <algorithm>  // for swap
+#include <math.h>
+#include "../interface/HEPTopTagger.h"
+
+using namespace std;
+using namespace fastjet;
+
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+namespace external {
+
+
+class MultiR_TopTagger {
+public:
+  MultiR_TopTagger(double max_fatjet_R,
+		   double min_fatjet_R,
+		   double step_R,
+		   double multiR_threshold,
+		   bool use_dR_max_triplet,
+		   const fastjet::ClusterSequence & cs, 
+		   const fastjet::PseudoJet & jet, 
+		   double mtmass, double mwmass
+		   );
+
+  ~MultiR_TopTagger();
+
+  //run tagger
+  void run_tagger();
+
+  // Return the candidate (and some properties) at R=R_min
+  external::HEPTopTagger cand_Rmin(){return _HEPTopTagger[_Rmin];}
+  const int & Rmin_raw() const {return _Rmin;}
+  const double Rmin() const {return _Rmin/10.;}
+  const double & mass_Rmin() const {return _mass_Rmin;}
+  const double & pt_Rmin() const {return _pt_Rmin;}
+  
+  // Access to all candidates and number-of-small-fatjets
+  external::HEPTopTagger HTTagger(int i)  {return _HEPTopTagger[i];}
+  const double n_small_fatjets(int i) {return _n_small_fatjets[i];}
+
+  void set_mode(int mode) {_mode = mode;}
+
+  void set_max_subjet_mass(double x) {_subjet_mass = x;}
+  void set_mass_drop_threshold(double x) {_mass_drop_threshold = x;}
+  void set_minpt_subjet(double x) {_minpt_subjet = x;}
+  void set_minpt_tag(double x) {_minpt_tag = x;}
+  void set_top_range(double top_range_min, double top_range_max) {_top_range[0] = top_range_min; _top_range[1] = top_range_max;}
+  void set_f_W(double f_W) {_f_W = f_W;}
+  void set_mass_ratio_cut(double mass_ratios_0, double mass_ratios_1, double mass_ratios_2) {_mass_ratios[0] = mass_ratios_0; _mass_ratios[1] = mass_ratios_1; _mass_ratios[2] = mass_ratios_2;}
+  void set_nfilt(unsigned nfilt) {_n_filt = nfilt;}
+  void set_Rfilt(double Rfilt) {_R_filt = Rfilt;}
+  void set_debug(bool debug) {_debug = debug;}
+ 
+
+private:
+  const ClusterSequence * _cs;
+  const PseudoJet *       _jet;
+  double _mtmass, _mwmass;
+  double _mass_drop_threshold;
+  double _subjet_mass;
+  double _minpt_subjet;
+  double _minpt_tag;
+  map<int,external::HEPTopTagger> _HEPTopTagger;
+  map<int,int> _n_small_fatjets;
+  int _Rmin;
+  int _mode;
+  double _mass_Rmin, _pt_Rmin;
+  double _mass_mean, _mass_width;
+  double _top_range[2];
+  unsigned _n_filt;
+  double _R_filt;
+  double _f_W;
+  double _mass_ratios[3];
+  double _max_fatjet_R, _min_fatjet_R, _step_R, _multiR_threshold;
+  bool _use_dR_max_triplet;
+  bool _debug;
+
+  void UnclusterFatjets(const vector<fastjet::PseudoJet> & big_fatjets, vector<fastjet::PseudoJet> & small_fatjets, const ClusterSequence & cs, const double small_radius);
+
+};
+//--------------------------------------------------------------------
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+};
+
+#endif // __MULTIR_TOPTAGGER_HH__
+
diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
new file mode 100644
index 0000000..6de8fb1
--- /dev/null
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
@@ -0,0 +1,210 @@
+//----------------------------------------------------------------------
+//  This file is free software; you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation; either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This file is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  The GNU General Public License is available at
+//  http://www.gnu.org/licenses/gpl.html or you can write to the Free Software
+//  Foundation, Inc.:
+//      59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+//----------------------------------------------------------------------
+
+#ifndef __MULTIRHEPTOPTAGGER_WRAPPER_HH__
+#define __MULTIRHEPTOPTAGGER_WRAPPER_HH__
+
+#include <fastjet/tools/TopTaggerBase.hh>
+#include <fastjet/CompositeJetStructure.hh>
+#include <sstream>
+
+FASTJET_BEGIN_NAMESPACE
+
+// Based on HEPTopTaggerWrapper.h
+
+class MultiRHEPTopTaggerStructure;
+
+class MultiRHEPTopTagger : public TopTaggerBase {
+public:
+  MultiRHEPTopTagger(double minSubjetPt, 
+		     double minCandPt, 
+		     double subjetMass, 
+		     double muCut, 
+		     double filtR,
+		     int filtN,
+		     int mode, 
+		     double minCandMass, 
+		     double maxCandMass, 
+		     double massRatioWidth, 
+		     double minM23Cut, 
+		     double minM13Cut, 
+		     double maxM13Cut,
+		     double R_max,
+		     double R_min) : minSubjetPt_(minSubjetPt),
+    minCandPt_(minCandPt),
+    subjetMass_(subjetMass),
+    muCut_(muCut),
+    filtR_(filtR),
+    filtN_(filtN),
+    mode_(mode),
+    minCandMass_(minCandMass),
+    maxCandMass_(maxCandMass),
+    massRatioWidth_(massRatioWidth),
+    minM23Cut_(minM23Cut),
+    minM13Cut_(minM13Cut),
+    maxM13Cut_(maxM13Cut),
+    R_max_(R_max),
+    R_min_(R_min)
+  {}
+
+  /// returns a textual description of the tagger
+  virtual std::string description() const;
+
+  /// runs the tagger on the given jet and
+  /// returns the tagged PseudoJet if successful, or a PseudoJet==0 otherwise
+  /// (standard access is through operator()).
+  ///  \param jet   the PseudoJet to tag
+  virtual PseudoJet result(const PseudoJet & jet) const;
+
+  // the type of the associated structure
+  typedef MultiRHEPTopTaggerStructure StructureType;
+
+private: 
+    double minSubjetPt_; // Minimal pT for subjets [GeV]
+    double minCandPt_;   // Minimal pT to return a candidate [GeV]
+ 
+    double subjetMass_; // Mass above which subjets are further unclustered
+    double muCut_; // Mass drop threshold
+    
+    double filtR_; // maximal filtering radius
+    int filtN_; // number of filtered subjets to use
+    
+    // HEPTopTagger Mode
+    // 0: do 2d-plane, return candidate with delta m_top minimal
+    // 1: return candidate with delta m_top minimal IF passes 2d plane
+    // 2: do 2d-plane, return candidate with max dj_sum
+    // 3: return candidate with max dj_sum IF passes 2d plane
+    // 4: return candidate built from leading three subjets after unclustering IF passes 2d plane
+    // Note: Original HTT was mode==1    
+    int mode_; 
+
+    // Top Quark mass window in GeV
+    double minCandMass_;
+    double maxCandMass_;
+    
+    double massRatioWidth_; // One sided width of the A-shaped window around m_W/m_top in %
+    double minM23Cut_; // minimal value of m23/m123
+    double minM13Cut_; // minimal value of atan(m13/m12)
+    double maxM13Cut_; // maximal value of atan(m13/m12)
+
+    double R_max_; // Maximal fatjet size to consider
+    double R_min_; // Minimal fatjet size to consider
+};
+
+
+class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTaggerBaseStructure {
+ public:
+   /// ctor with pieces initialisation
+   MultiRHEPTopTaggerStructure(const std::vector<PseudoJet>& pieces_in,
+                  const JetDefinition::Recombiner *recombiner = 0) : CompositeJetStructure(pieces_in, recombiner),
+    _top_mass(0.0),
+    _unfiltered_mass(0.0),
+    _pruned_mass(0.0),
+    _fW(-1.),
+    _mass_ratio_passed(-1),
+    W_rec(recombiner), 
+    rW_(){}
+  
+   // Return W subjet
+   inline PseudoJet const & W() const{ 
+     rW_ = join(_pieces[0], _pieces[1], *W_rec);
+     return rW_;
+   }
+     
+   // Return leading subjet in W
+   inline PseudoJet  W1() const{
+     assert(W().pieces().size()>0);
+     return W().pieces()[0];
+   }
+       
+   /// returns the second W subjet
+   inline PseudoJet W2() const{
+     assert(W().pieces().size()>1);
+     return W().pieces()[1];
+   }
+ 
+
+   /// returns the non-W subjet
+   /// It will have 1 or 2 pieces depending on whether the tagger has
+   /// found 3 or 4 pieces
+   inline const PseudoJet & non_W() const{ 
+     return _pieces[2];
+   }
+ 
+   /// returns the candidate mass
+   inline double top_mass() const {return _top_mass;}
+
+   /// returns the unfiltered mass
+   inline double unfiltered_mass() const {return _unfiltered_mass;}
+
+   /// returns the pruned mass
+   inline double pruned_mass() const {return _pruned_mass;}
+
+   /// returns fW
+   inline double fW() const {return _fW;}
+
+   /// returns Rmin
+   inline double R_min() const {return _Rmin;}
+
+   /// returns if 2d-mass plane cuts were passed
+   inline double mass_ratio_passed() const {return _mass_ratio_passed;}
+    
+ protected:
+      double _top_mass;
+      double _unfiltered_mass;
+      double _pruned_mass;
+      double _fW;      
+      int _mass_ratio_passed;
+      double _Rmin;
+      
+      const JetDefinition::Recombiner  * W_rec;
+ 
+      mutable PseudoJet rW_;
+
+   // allow the tagger to set these
+   friend class HEPTopTagger;
+   friend class MultiRHEPTopTagger;
+ };
+
+
+//------------------------------------------------------------------------
+// description of the tagger
+inline std::string MultiRHEPTopTagger::description() const{ 
+
+  std::ostringstream oss;
+  oss << "MultiRHEPTopTagger with: "
+      << "minSubjetPt = " << minSubjetPt_ 
+      << "minCandPt = " << minCandPt_ 
+      << "subjetMass = " << subjetMass_ 
+      << "muCut = " << muCut_ 
+      << "filtR = " << filtR_ 
+      << "filtN = " << filtN_     
+      << "mode = " << mode_ 
+      << "minCandMass = " << minCandMass_ 
+      << "maxCandMass = " << maxCandMass_ 
+      << "massRatioWidth = " << massRatioWidth_ 
+      << "minM23Cut = " << minM23Cut_ 
+      << "minM13Cut = " << minM13Cut_
+      << "Rmax = " << R_max_ 
+      << "Rmin = " << R_min_ << std::endl;
+  return oss.str();
+}
+
+
+FASTJET_END_NAMESPACE
+
+#endif // __MULTIRHEPTOPTAGGER_HH__
diff --git a/RecoJets/JetAlgorithms/src/HEPTopTagger.cc b/RecoJets/JetAlgorithms/src/HEPTopTagger.cc
new file mode 100644
index 0000000..2c230bc
--- /dev/null
+++ b/RecoJets/JetAlgorithms/src/HEPTopTagger.cc
@@ -0,0 +1,350 @@
+
+#include "../interface/HEPTopTagger.h"
+
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+namespace external {
+
+bool HEPTopTagger::_first_time = true;
+
+void HEPTopTagger::print_banner() {
+  if (!_first_time) {return;}
+  _first_time = false;
+
+  std::cout << "#--------------------------------------------------------------------------\n";
+  std::cout << "#                   HEPTopTagger - under construction                      \n";
+  std::cout << "#                                                                          \n";
+  std::cout << "# Please cite JHEP 1010 (2010) 078 [arXiv:1006.2833 [hep-ph]]              \n";
+  std::cout << "# and Phys.Rev. D89 (2014) 074047 [arXiv:1312.1504 [hep-ph]]               \n";
+  std::cout << "#--------------------------------------------------------------------------\n";
+  get_setting();
+}
+
+double HEPTopTagger::perp(const PseudoJet & vec, const fastjet::PseudoJet & ref) {
+  double ref_ref = ref.px() * ref.px() + ref.py() * ref.py() + ref.pz() * ref.pz();
+  double vec_ref = vec.px() * ref.px() + vec.py() * ref.py() + vec.pz() * ref.pz();
+  double per_per = vec.px() * vec.px() + vec.py() * vec.py() + vec.pz() * vec.pz();
+  if (ref_ref > 0.) 
+    per_per -= vec_ref * vec_ref / ref_ref;
+  if (per_per < 0.) 
+    per_per = 0.;
+  return sqrt(per_per);
+}
+
+double HEPTopTagger::djademod (const fastjet::PseudoJet& subjet_i, const fastjet::PseudoJet& subjet_j, const fastjet::PseudoJet& ref) {
+  double dj = -1.0;
+  double delta_phi = subjet_i.delta_phi_to(subjet_j);
+  double delta_eta = subjet_i.eta() - subjet_j.eta();
+  double delta_R = sqrt(delta_eta * delta_eta + delta_phi * delta_phi);	
+  dj = perp(subjet_i, ref) * perp(subjet_j, ref) * pow(delta_R, 4.);
+  return dj;
+}
+
+double HEPTopTagger::fW() {
+  // Minimal:
+  // |(m_ij / m_123) / (m_w/ m_t) - 1|
+
+  double m12 = (_top_subs[0] + _top_subs[1]).m();
+  double m13 = (_top_subs[0] + _top_subs[2]).m();
+  double m23 = (_top_subs[1] + _top_subs[2]).m();
+  double m123 = (_top_subs[0] + _top_subs[1] + _top_subs[2]).m();
+
+  double fw12 = fabs( (m12/m123) / (_mwmass/_mtmass) - 1);
+  double fw13 = fabs( (m13/m123) / (_mwmass/_mtmass) - 1);
+  double fw23 = fabs( (m23/m123) / (_mwmass/_mtmass) - 1);
+  
+  return std::min(fw12, std::min(fw13, fw23));  
+}
+
+//Find hard substructures
+void HEPTopTagger::FindHardSubst(const PseudoJet & this_jet, std::vector<fastjet::PseudoJet> & t_parts) {
+  PseudoJet parent1(0, 0, 0, 0), parent2(0, 0, 0, 0);
+  if (this_jet.m() < _max_subjet_mass || !this_jet.validated_cs()->has_parents(this_jet, parent1, parent2)) {
+    t_parts.push_back(this_jet);
+  } else {
+    if (parent1.m() < parent2.m()) 
+      std::swap(parent1, parent2);   
+    FindHardSubst(parent1, t_parts);
+    if (parent1.m() < _mass_drop_threshold * this_jet.m())
+      FindHardSubst(parent2, t_parts);   
+  }
+}
+
+//store subjets as vector<PseudoJet> with [0]->b [1]->W-jet 1 [2]->W-jet 2
+void HEPTopTagger::store_topsubjets(const std::vector<PseudoJet>& top_subs) {
+  _top_subjets.resize(0);
+  double m12 = (top_subs[0] + top_subs[1]).m();
+  double m13 = (top_subs[0] + top_subs[2]).m();
+  double m23 = (top_subs[1] + top_subs[2]).m();
+  double dm12 = fabs(m12 - _mwmass);
+  double dm13 = fabs(m13 - _mwmass);
+  double dm23 = fabs(m23 - _mwmass);
+  
+  if (dm23 <= dm12 && dm23 <= dm13) {
+    _top_subjets.push_back(top_subs[0]); 
+    _top_subjets.push_back(top_subs[1]); 
+    _top_subjets.push_back(top_subs[2]);	
+  } else if (dm13 <= dm12 && dm13 < dm23) {
+    _top_subjets.push_back(top_subs[1]);
+    _top_subjets.push_back(top_subs[0]);
+    _top_subjets.push_back(top_subs[2]);
+  } else if (dm12 < dm23 && dm12 < dm13) {
+    _top_subjets.push_back(top_subs[2]);
+    _top_subjets.push_back(top_subs[0]);
+    _top_subjets.push_back(top_subs[1]);
+  }
+  _W = _top_subjets[1] + _top_subjets[2];
+  return;
+}
+
+//check mass plane cuts
+bool HEPTopTagger::check_mass_criteria(const std::vector<PseudoJet> & top_subs) const {
+  bool is_passed = false;
+  double m12 = (top_subs[0] + top_subs[1]).m();
+  double m13 = (top_subs[0] + top_subs[2]).m();
+  double m23 = (top_subs[1] + top_subs[2]).m();
+  double m123 = (top_subs[0] + top_subs[1] + top_subs[2]).m();
+  if (
+      (atan(m13/m12) > _m13cutmin && _m13cutmax > atan(m13/m12)
+       && (m23/m123 > _rmin && _rmax > m23/m123))
+      ||
+      (((m23/m123) * (m23/m123) < 1 - _rmin * _rmin* (1 + (m13/m12) * (m13/m12)))
+       &&
+       ((m23/m123) * (m23/m123) > 1 - _rmax * _rmax * (1 + (m13/m12) * (m13/m12)))
+       && 
+       (m23/m123 > _m23cut))
+      ||
+      (((m23/m123) * (m23/m123) < 1 - _rmin * _rmin * (1 + (m12/m13) * (m12/m13)))
+       &&
+       ((m23/m123) * (m23/m123) > 1 - _rmax * _rmax * (1 + (m12/m13) * (m12/m13)))
+       && 
+       (m23/m123 > _m23cut))
+      ) { 
+    is_passed = true;
+  }
+  return is_passed;
+}
+
+HEPTopTagger::HEPTopTagger() {}
+
+HEPTopTagger::HEPTopTagger(fastjet::PseudoJet jet) : 
+  _jet(&jet), _mtmass(172.3), _mwmass(80.4), 
+  _mass_drop_threshold(0.8), _max_subjet_mass(30.), 
+  _mtmin(150.), _mtmax(200.), _rmin(0.85*80.4/172.3), _rmax(1.15*80.4/172.3), 
+  _m23cut(0.35), _m13cutmin(0.2), _m13cutmax(1.3), 
+  _nfilt(5), _Rfilt(0.3), _Rprun(1.5), _jet_algorithm_filter(fastjet::cambridge_algorithm), _jet_algorithm_recluster(fastjet::cambridge_algorithm), _zcut(0.1),
+  _rcut_factor(0.5), _mode(0), _minpt_tag(200.), _minpt_subjet(0.), _debug(false), _fat(jet)
+{}
+
+HEPTopTagger::HEPTopTagger(fastjet::PseudoJet jet, 
+			   double mtmass, double mwmass
+			   ) : 
+  _jet(&jet), _mtmass(mtmass), _mwmass(mwmass), 
+  _mass_drop_threshold(0.8), _max_subjet_mass(30.), 
+  _mtmin(150.), _mtmax(200.), _rmin(0.85*mwmass/mtmass), _rmax(1.15*mwmass/mtmass), 
+  _m23cut(0.35), _m13cutmin(0.2), _m13cutmax(1.3), 
+  _nfilt(5), _Rfilt(0.3), _Rprun(1.5), _jet_algorithm_filter(fastjet::cambridge_algorithm), _jet_algorithm_recluster(fastjet::cambridge_algorithm), _zcut(0.1),
+  _rcut_factor(0.5), _mode(0), _minpt_tag(200.), _debug(false), _fat(jet)
+{}
+
+void HEPTopTagger::run_tagger() {
+  print_banner();
+
+  if ((_mode != Mode::EARLY_MASSRATIO_SORT_MASS) 
+      && (_mode != Mode::LATE_MASSRATIO_SORT_MASS) 
+      && (_mode != Mode::EARLY_MASSRATIO_SORT_MODDJADE)
+      && (_mode != Mode::LATE_MASSRATIO_SORT_MODDJADE)
+      && (_mode != Mode::TWO_STEP_FILTER) ) {
+    std::cout << "ERROR: UNKNOWN MODE" << std::endl;
+    return;
+  }
+  
+  //initialization
+  _djsum = 0.;
+  _delta_top = 1000000000000.0;
+  _pruned_mass = 0.;
+  _unfiltered_mass = 0.;
+  _top_candidate.reset(0., 0., 0., 0.);
+  _parts_size = 0;
+  _is_maybe_top = _is_masscut_passed = _is_ptmincut_passed = false;
+  _top_subs.clear();
+  _top_subjets.clear();
+  _top_hadrons.clear();
+  _top_parts.clear();
+  
+  //find hard substructures
+  FindHardSubst(*_jet, _top_parts);
+  _parts_size = _top_parts.size();
+  
+  if (_top_parts.size() < 3) { 
+    if (_debug) {std::cout << "< 3 hard substructures " << std::endl;}
+    return; //such events are not interesting   
+  }
+  
+  // Sort subjets-after-unclustering by pT.
+  // Necessary so that two-step-filtering can use the leading-three.
+  _top_parts=sorted_by_pt(_top_parts);
+
+  // loop over triples
+  _top_parts = sorted_by_pt(_top_parts);
+  for (unsigned rr = 0; rr < _top_parts.size(); rr++) {
+    for (unsigned ll = rr + 1; ll < _top_parts.size(); ll++) {
+      for (unsigned kk = ll + 1; kk < _top_parts.size(); kk++) {
+	
+	// two-step filtering 
+	// This means that we only look at the triplet formed by the
+	// three leading-in-pT subjets-after-unclustering.
+	if((_mode==Mode::TWO_STEP_FILTER) && rr>0)
+	  continue;
+	if((_mode==Mode::TWO_STEP_FILTER) && ll>1)
+	  continue;
+	if((_mode==Mode::TWO_STEP_FILTER) && kk>2)
+	  continue;
+
+      	//pick triple
+	PseudoJet triple = join(_top_parts[rr], _top_parts[ll], _top_parts[kk]);
+	
+	//filtering 
+	double filt_top_R 
+	  = std::min(_Rfilt, 0.5*sqrt(std::min(_top_parts[kk].squared_distance(_top_parts[ll]), 
+				     std::min(_top_parts[rr].squared_distance(_top_parts[ll]), 
+					 _top_parts[kk].squared_distance(_top_parts[rr])))));
+	JetDefinition filtering_def(_jet_algorithm_filter, filt_top_R);
+	fastjet::Filter filter(filtering_def, fastjet::SelectorNHardest(_nfilt) * fastjet::SelectorPtMin(_minpt_subjet));
+	PseudoJet topcandidate = filter(triple);
+
+
+	//mass window cut
+  	if (topcandidate.m() < _mtmin || _mtmax < topcandidate.m()) continue;
+
+	// Sanity cut: can't recluster less than 3 objects into three subjets
+	if (topcandidate.pieces().size() < 3)
+	  continue;
+       
+	// Recluster to 3 subjets and apply mass plane cuts
+	// Use a self-deleting CS-pointer. Taken from CMSSW version of HTT
+	// Initial CMSSW edit by CKV, suggested by G. P. Salam)	
+	JetDefinition reclustering(_jet_algorithm_recluster, 3.14);
+	ClusterSequence *  cs_top_sub = new ClusterSequence(topcandidate.pieces(), reclustering);
+        std::vector <PseudoJet> top_subs = sorted_by_pt(cs_top_sub->exclusive_jets(3));         
+	cs_top_sub->delete_self_when_unused();
+
+	// Require the third subjet to be above the pT threshold
+	if (top_subs[2].perp() < _minpt_subjet)
+	  continue;
+
+	// Modes with early 2d-massplane cuts
+	if (_mode == Mode::EARLY_MASSRATIO_SORT_MASS      && !check_mass_criteria(top_subs)) {continue;}
+	if (_mode == Mode::EARLY_MASSRATIO_SORT_MODDJADE  && !check_mass_criteria(top_subs)) {continue;}
+
+	//is this candidate better than the other? -> update
+	double deltatop = fabs(topcandidate.m() - _mtmass);
+	double djsum = djademod(top_subs[0], top_subs[1], topcandidate) 
+			       + djademod(top_subs[0], top_subs[2], topcandidate)
+			       + djademod(top_subs[1], top_subs[2], topcandidate);
+	bool better = false;
+
+	// Modes 0 and 1 sort by top mass
+	if ( (_mode == Mode::EARLY_MASSRATIO_SORT_MASS) 
+	     || (_mode == Mode::LATE_MASSRATIO_SORT_MASS)) {
+	  if (deltatop < _delta_top) 
+	    better = true;
+	}
+	// Modes 2 and 3 sort by modified jade distance
+	else if ( (_mode == Mode::EARLY_MASSRATIO_SORT_MODDJADE) 
+		  || (_mode == Mode::LATE_MASSRATIO_SORT_MODDJADE)) {
+	  if (djsum > _djsum) 
+	    better = true;
+	}
+	// Mode 4 is the two-step filtering. No sorting necessary as
+	// we just look at the triplet of highest pT objects after
+	// unclustering
+	else if (_mode == Mode::TWO_STEP_FILTER) {
+	  better = true;
+	} 
+	else {
+	  std::cout << "ERROR: UNKNOWN MODE (IN DISTANCE MEASURE SELECTION)" << std::endl;
+	  return;
+	}
+
+	if (better) {
+	  _djsum = djsum;
+	  _delta_top = deltatop; 
+	  _is_maybe_top = true;
+	  _top_candidate = topcandidate;
+	  _top_subs = top_subs;
+	  store_topsubjets(top_subs);
+	  _top_hadrons = topcandidate.constituents();
+	  //pruning
+	  JetDefinition jet_def_prune(fastjet::cambridge_algorithm, _Rprun);
+	  fastjet::Pruner pruner(jet_def_prune, _zcut, _rcut_factor);
+	  PseudoJet prunedjet = pruner(triple);
+	  _pruned_mass = prunedjet.m();
+	  _unfiltered_mass = triple.m();
+	  
+	  //are all criteria fulfilled?
+	  _is_masscut_passed = false;
+	  if (check_mass_criteria(top_subs)) {
+	    _is_masscut_passed = true;
+	  }
+	  _is_ptmincut_passed = false;
+	  if (_top_candidate.pt() > _minpt_tag) {
+	    _is_ptmincut_passed = true;
+	  }
+	}//end better
+      }//end kk
+    }//end ll
+  }//end rr
+  return;
+}
+
+void HEPTopTagger::get_info() const {  
+  std::cout << "#--------------------------------------------------------------------------\n";
+  std::cout << "#                          HEPTopTagger Result" << std::endl;
+  std::cout << "#" << std::endl;
+  std::cout << "# is top candidate: " << _is_maybe_top << std::endl;
+  std::cout << "# mass plane cuts passed: " << _is_masscut_passed << std::endl;
+  std::cout << "# top candidate mass: " << _top_candidate.m() << std::endl;
+  std::cout << "# top candidate (pt, eta, phi): (" 
+       << _top_candidate.perp() << ", "
+       << _top_candidate.eta() << ", "
+       << _top_candidate.phi_std() << ")" << std::endl;
+  std::cout << "# top hadrons: " << _top_hadrons.size() << std::endl;
+  std::cout << "# hard substructures: " << _parts_size << std::endl;
+  std::cout << "# |m - mtop| : " << _delta_top << std::endl; 
+  std::cout << "# djsum : " << _djsum << std::endl;
+  std::cout << "# is consistency cut passed: " << _is_ptmincut_passed << std::endl; 
+  std::cout << "#--------------------------------------------------------------------------\n";
+  return;
+}
+
+void HEPTopTagger::get_setting() const {
+  std::cout << "#--------------------------------------------------------------------------\n";
+  std::cout << "#                         HEPTopTagger Settings" << std::endl;
+  std::cout << "#" << std::endl;
+  std::cout << "# mode: " << _mode << " (0 = EARLY_MASSRATIO_SORT_MASS) " << std::endl;
+  std::cout << "#        "         << " (1 = LATE_MASSRATIO_SORT_MASS)  " << std::endl;
+  std::cout << "#        "         << " (2 = EARLY_MASSRATIO_SORT_MODDJADE)  " << std::endl;
+  std::cout << "#        "         << " (3 = LATE_MASSRATIO_SORT_MODDJADE)  " << std::endl;
+  std::cout << "#        "         << " (4 = TWO_STEP_FILTER)  " << std::endl;
+  std::cout << "# top mass: " << _mtmass << "    ";
+  std::cout << "W mass: " << _mwmass << std::endl;
+  std::cout << "# top mass window: [" << _mtmin << ", " << _mtmax << "]" << std::endl;
+  std::cout << "# W mass ratio: [" << _rmin << ", " << _rmax << "] (["
+       <<_rmin*_mtmass/_mwmass<< "%, "<< _rmax*_mtmass/_mwmass << "%])"<< std::endl;
+  std::cout << "# mass plane cuts: (m23cut, m13min, m13max) = (" 
+       << _m23cut << ", " << _m13cutmin << ", " << _m13cutmax << ")" << std::endl;
+  std::cout << "# mass_drop_threshold: " << _mass_drop_threshold << "    ";
+  std::cout << "max_subjet_mass: " << _max_subjet_mass << std::endl;
+  std::cout << "# R_filt: " << _Rfilt << "    ";
+  std::cout << "n_filt: " << _nfilt << std::endl;
+  std::cout << "# minimal subjet pt: " << _minpt_subjet << std::endl;
+  std::cout << "# minimal reconstructed pt: " << _minpt_tag << std::endl;
+  std::cout << "# internal jet algorithms (0 = kt, 1 = C/A, 2 = anti-kt): " << std::endl; 
+  std::cout << "#   filtering: "<< _jet_algorithm_filter << std::endl;
+  std::cout << "#   reclustering: "<< _jet_algorithm_recluster << std::endl;
+  std::cout << "#--------------------------------------------------------------------------\n";
+  
+  return;
+}
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+};
diff --git a/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc b/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc
index 2d670fa..a82b037 100644
--- a/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc
+++ b/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc
@@ -22,15 +22,17 @@
 #include <fastjet/Error.hh>
 #include <fastjet/JetDefinition.hh>
 #include <fastjet/ClusterSequence.hh>
+#include "fastjet/PseudoJet.hh"
+#include "fastjet/tools/Pruner.hh"
+#include "fastjet/tools/Filter.hh"
 
+#include <math.h>
 #include <limits>
 #include <cassert>
 using namespace std;
 
-// namespace hack so that this tagger can have the same name as the core code
-namespace external {
 #include "RecoJets/JetAlgorithms/interface/HEPTopTagger.h"
-}
+
 
 FASTJET_BEGIN_NAMESPACE
 
@@ -38,6 +40,7 @@ FASTJET_BEGIN_NAMESPACE
 // returns the tagged PseudoJet if successful, 0 otherwise
 //  - jet   the PseudoJet to tag
 PseudoJet HEPTopTagger::result(const PseudoJet & jet) const{
+
   // make sure that there is a "regular" cluster sequence associated
   // with the jet. Note that we also check it is valid (to avoid a
   // more criptic error later on)
@@ -45,18 +48,39 @@ PseudoJet HEPTopTagger::result(const PseudoJet & jet) const{
     throw Error("HEPTopTagger can only be applied on jets having an associated (and valid) ClusterSequence");
   }
 
-  external::HEPTopTagger tagger(*jet.associated_cluster_sequence(), jet);
-  tagger.set_top_range(0.0, 10000.0); // don't do top mass cut; this can be applied later
-  tagger.set_mass_drop_threshold(_mass_drop_threshold);
-  tagger.set_max_subjet_mass(_max_subjet_mass);
+  external::HEPTopTagger tagger(jet);
 
-  tagger.run_tagger();
+  // translate the massRatioWidth (which should be the half-width given in %) 
+  // to values useful for the A-shape cuts
+  double mw_over_mt = 80.4/172.3;
+  double ratio_min = mw_over_mt * (100.-massRatioWidth_)/100.;
+  double ratio_max = mw_over_mt * (100.+massRatioWidth_)/100.;
+ 
   
-  // check that we passed the tagger; if not return a blank PseudoJet
-  if (_use_subjet_mass_cuts) {
-    if (!tagger.is_masscut_passed()) // encompasses is_maybe_top() plus subjet mass cuts
-      return PseudoJet();
-  } else if (!tagger.is_maybe_top())
+  // Unclustering, Filtering & Subjet Settings
+  tagger.set_max_subjet_mass(subjetMass_);
+  tagger.set_mass_drop_threshold(muCut_);
+  tagger.set_Rfilt(filtR_);
+  tagger.set_nfilt(filtN_);
+  tagger.set_minpt_subjet(minSubjetPt_); 
+
+  // How to select among candidates
+  tagger.set_mode(mode_);
+  
+  // Requirements to accept a candidate
+  tagger.set_minpt_tag(minCandPt_); 
+  tagger.set_top_range(minCandMass_, maxCandMass_); 
+  tagger.set_mass_ratio_cut(minM23Cut_, minM13Cut_, maxM13Cut_);
+  tagger.set_mass_ratio_range(ratio_min, ratio_max);
+
+  tagger.run_tagger();
+
+  // Requires:
+  //   - top mass window
+  //   - mass ratio cuts
+  //   - minimal candidate pT
+  // If this is not intended: use loose top mass and ratio windows
+  if (!tagger.is_tagged())
     return PseudoJet();
   
   // create the result and its structure
@@ -71,24 +95,17 @@ PseudoJet HEPTopTagger::result(const PseudoJet & jet) const{
   PseudoJet W2 = subjets[2];
   PseudoJet W = join(subjets[1], subjets[2], *rec);
 
-
   PseudoJet result = join<HEPTopTaggerStructure>( W1, W2, non_W, *rec);
-  //HEPTopTaggerStructure *s = (HEPTopTaggerStructure*) result.structure_non_const_ptr();
-//  s->_cos_theta_w = _cos_theta_W(result);
-
-  // Check selectors to see if identified top, W pass and cuts
-  //
-  // Note that we could perhaps ensure this cut before constructing
-  // the result structure but this has the advantage that the top
-  // 4-vector is already available and does not have to de re-computed
-  if (! _top_selector.pass(result) || ! _W_selector.pass(W)) {
-    result *= 0.0;
-  }
+  HEPTopTaggerStructure *s = (HEPTopTaggerStructure*) result.structure_non_const_ptr();
+
+  s->_top_mass = tagger.t().m();
+  s->_pruned_mass = tagger.pruned_mass();
+  s->_unfiltered_mass = tagger.unfiltered_mass();
+  s->_fW = tagger.fW();
+  s->_mass_ratio_passed = tagger.is_masscut_passed();
 
+  // Removed selectors as all cuts are applied ion HTT
   return result;
 }
 
-
-
-
 FASTJET_END_NAMESPACE
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
new file mode 100644
index 0000000..2e059c3
--- /dev/null
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
@@ -0,0 +1,132 @@
+#include "../interface/MultiRHEPTopTagger.h"
+
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+namespace external {
+
+
+//uncluster a fat jet to subjets of given cone size
+void MultiR_TopTagger::UnclusterFatjets(const vector<fastjet::PseudoJet> & big_fatjets, 
+					vector<fastjet::PseudoJet> & small_fatjets, 
+					const ClusterSequence & cs, 
+					const double small_radius) {
+  for (unsigned i=0; i < big_fatjets.size(); i++) {
+    PseudoJet this_jet = big_fatjets[i];
+    PseudoJet parent1(0, 0, 0, 0), parent2(0, 0, 0, 0);
+    bool test = cs.has_parents(this_jet, parent1, parent2);
+    double dR = sqrt(parent1.squared_distance(parent2));
+
+    if (!test || dR<small_radius) {
+      small_fatjets.push_back(this_jet);
+    } else {
+      vector<fastjet::PseudoJet> parents;
+      parents.push_back(parent1);
+      parents.push_back(parent2);
+      UnclusterFatjets(parents, small_fatjets, cs, small_radius);
+    }
+  }
+}
+
+//////MultiR_TopTagger/////////////////////////
+//Start with a fatjet clustered with radius max_fatjet_R
+//Then run the HEPTopTagger for fatjets with smaller radii
+//Quantities stored as map<double,...> where the key is the fatjet radius
+
+MultiR_TopTagger::MultiR_TopTagger(double max_fatjet_R,
+				   double min_fatjet_R,
+				   double step_R,
+				   double multiR_threshold,
+				   bool use_dR_max_triplet,
+				   const fastjet::ClusterSequence & cs, 
+				   const fastjet::PseudoJet & jet, 
+				   double mtmass, double mwmass
+				   ) : _cs(&cs),  _jet(&jet),
+				       _mtmass(mtmass),	_mwmass(mwmass), _max_fatjet_R(max_fatjet_R), _min_fatjet_R(min_fatjet_R), _step_R(step_R), _multiR_threshold(multiR_threshold), _use_dR_max_triplet(use_dR_max_triplet), _debug(false)
+{}
+
+void MultiR_TopTagger::run_tagger() {
+  if (_debug) {
+    cout << "============================="  << endl 
+	 << "new MultiR" << endl;
+  }
+  
+  vector<fastjet::PseudoJet> big_fatjets;
+  vector<fastjet::PseudoJet> small_fatjets;
+  
+  big_fatjets.push_back(* _jet);
+  _Rmin = 0;
+  _mass_Rmin = 0.;
+  _pt_Rmin = 0.;
+
+  int maxR = int(_max_fatjet_R * 10);
+  int minR = int(_min_fatjet_R * 10);
+  int stepR = int(_step_R * 10);
+
+  for (int R = maxR; R >= minR; R -= stepR) {
+    
+    // TODO: check!
+    // Deactivated this piece for now as dR_max_triplet is not used.
+    // Problem in lines below?
+    //  
+    //float dR_max_triplet = 9999;
+    //if (_use_dR_max_triplet) {
+    //  small_fatjets = big_fatjets;
+    //  dR_max_triplet = R / 10.;   
+    //} else {
+
+    UnclusterFatjets(big_fatjets, small_fatjets, *_cs, R / 10.);
+    //}
+    
+    if (_debug) {cout << "R = " << R << " -> n_small_fatjets = " << small_fatjets.size();}
+    
+    _n_small_fatjets[R] = small_fatjets.size();
+
+    // We are sorting by pt - so start with a negative dummy
+    double dummy = -99999;
+
+    for (unsigned i = 0; i < small_fatjets.size(); i++) {
+      external::HEPTopTagger htt(small_fatjets[i], _mtmass, _mwmass);
+      htt.set_top_range(_top_range[0], _top_range[1]);
+      htt.set_mass_ratio_cut(_mass_ratios[0], _mass_ratios[1], _mass_ratios[2]);
+      htt.set_max_subjet_mass(_subjet_mass);
+      htt.set_minpt_subjet(_minpt_subjet);
+      htt.set_minpt_tag(_minpt_tag);
+      htt.set_mass_drop_threshold(_mass_drop_threshold);
+      htt.set_nfilt(_n_filt);
+      htt.set_Rfilt(_R_filt);
+      htt.set_mass_ratio_range((1.-_f_W)*_mwmass/_mtmass, (1.+_f_W)*_mwmass/_mtmass); 
+      htt.set_mode(_mode); 
+      
+      htt.run_tagger();
+     
+      if (htt.top_candidate().perp() > dummy) {
+	dummy = htt.top_candidate().perp();
+	_HEPTopTagger[R] = htt;
+      }
+    } //End of loop over small_fatjets
+    
+    // Only check if we have not found Rmin yet
+    if (_Rmin == 0 && R < maxR) {                 
+      // If the new mass is OUTSIDE the window ..
+      if (_HEPTopTagger[R].top_candidate().m() < (1-_multiR_threshold)*_HEPTopTagger[maxR].top_candidate().m())
+	// .. set _Rmin to the previous mass 
+	_Rmin = R + stepR;
+    }
+    
+    big_fatjets = small_fatjets;
+    small_fatjets.clear();
+  }//End of loop over R
+
+  // if we did not find Rmin in the loop, pick the last value
+  if (_Rmin == 0 && _HEPTopTagger[maxR].top_candidate().m() > 0)
+    _Rmin = minR;
+
+  _mass_Rmin = _HEPTopTagger[_Rmin].top_candidate().m();
+  _pt_Rmin = _HEPTopTagger[_Rmin].top_candidate().perp();
+ 
+  if (_debug) {cout << "MultiR done" << endl;}
+}
+
+MultiR_TopTagger::~MultiR_TopTagger(){}
+
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+};
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
new file mode 100644
index 0000000..a6b8433
--- /dev/null
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
@@ -0,0 +1,116 @@
+//----------------------------------------------------------------------
+//  This file is free software; you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation; either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This file is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  The GNU General Public License is available at
+//  http://www.gnu.org/licenses/gpl.html or you can write to the Free Software
+//  Foundation, Inc.:
+//      59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+//----------------------------------------------------------------------
+
+#include "RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h"
+
+#include <fastjet/Error.hh>
+#include <fastjet/JetDefinition.hh>
+#include <fastjet/ClusterSequence.hh>
+#include "fastjet/PseudoJet.hh"
+#include "fastjet/tools/Pruner.hh"
+#include "fastjet/tools/Filter.hh"
+
+#include <math.h>
+#include <limits>
+#include <cassert>
+using namespace std;
+
+#include "RecoJets/JetAlgorithms/interface/HEPTopTagger.h"
+#include "RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h"
+
+FASTJET_BEGIN_NAMESPACE
+
+//------------------------------------------------------------------------
+// returns the tagged PseudoJet if successful, 0 otherwise
+//  - jet   the PseudoJet to tag
+PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
+
+  // make sure that there is a "regular" cluster sequence associated
+  // with the jet. Note that we also check it is valid (to avoid a
+  // more criptic error later on)
+  if (!jet.has_valid_cluster_sequence()){
+    throw Error("HEPTopTagger can only be applied on jets having an associated (and valid) ClusterSequence");
+  }
+
+  double m_W = 80.4;
+  double m_top = 172.3;
+
+  external::MultiR_TopTagger tagger(R_max_,   // R_max
+				    R_min_,   // R_min
+				    0.1,   // R_step (using a stepsize smaller than 0.1 would currently not work)
+				    0.2,   // Mass-drop threshold
+				    false, // use_dR_max_triplet
+				    *(jet.associated_cluster_sequence()),
+				    jet,
+				    m_top,
+				    m_W);
+   
+  // Unclustering, Filtering & Subjet Settings
+  tagger.set_max_subjet_mass(subjetMass_);
+  tagger.set_mass_drop_threshold(muCut_); 
+  tagger.set_Rfilt(filtR_);
+  tagger.set_nfilt(filtN_);
+  tagger.set_minpt_subjet(minSubjetPt_);
+
+  // How to select among candidates
+  tagger.set_mode(mode_);
+  
+  // Requirements to accept a candidate
+  tagger.set_minpt_tag(minCandPt_); 
+  tagger.set_top_range(minCandMass_, maxCandMass_); 
+  tagger.set_mass_ratio_cut(minM23Cut_, minM13Cut_, maxM13Cut_);
+  tagger.set_f_W(massRatioWidth_/100.);
+
+  tagger.run_tagger();
+  
+  // MultiR tagging requirements:
+  //   - found a valid R_min
+  //   - HTT top mass window
+  //   - HTT mass ratio cuts
+  //   - HTT minimal candidate pT
+  // If this is not intended: use loose top mass and ratio windows
+  if ( (tagger.Rmin_raw()==0) || (! tagger.cand_Rmin().is_tagged()))
+      return PseudoJet();
+  
+  // create the result and its structure
+  const JetDefinition::Recombiner *rec
+    = jet.associated_cluster_sequence()->jet_def().recombiner();
+
+  const vector<PseudoJet>& subjets = tagger.cand_Rmin().top_subjets();
+  assert(subjets.size() == 3);
+
+  PseudoJet non_W = subjets[0];
+  PseudoJet W1 = subjets[1];
+  PseudoJet W2 = subjets[2];
+  PseudoJet W = join(subjets[1], subjets[2], *rec);
+
+  PseudoJet result = join<MultiRHEPTopTaggerStructure>( W1, W2, non_W, *rec);
+  MultiRHEPTopTaggerStructure *s = (MultiRHEPTopTaggerStructure*) result.structure_non_const_ptr();
+
+  s->_top_mass = tagger.cand_Rmin().t().m();
+  s->_pruned_mass = tagger.cand_Rmin().pruned_mass();
+  s->_unfiltered_mass = tagger.cand_Rmin().unfiltered_mass();
+  s->_fW = tagger.cand_Rmin().fW();
+  s->_mass_ratio_passed = tagger.cand_Rmin().is_masscut_passed();
+  s->_Rmin = tagger.Rmin();
+  // TODO: Add Rmin(expected)
+  
+
+  return result;
+}
+
+FASTJET_END_NAMESPACE
diff --git a/RecoJets/JetProducers/plugins/CATopJetProducer.cc b/RecoJets/JetProducers/plugins/CATopJetProducer.cc
index f16b065..d81d7b4 100644
--- a/RecoJets/JetProducers/plugins/CATopJetProducer.cc
+++ b/RecoJets/JetProducers/plugins/CATopJetProducer.cc
@@ -45,15 +45,7 @@ CATopJetProducer::CATopJetProducer(edm::ParameterSet const& conf):
 						  conf.getParameter<double> ("rFrac"),
 						  conf.getParameter<double> ("adjacencyParam"))
 		);
-	}
-	else if (tagAlgo_ == FJ_HEP_TOPTAG ) {
-		fjHEPTopTagger_ = std::auto_ptr<fastjet::HEPTopTagger>(
-			new fastjet::HEPTopTagger(conf.getParameter<double>("muCut"),
-						  conf.getParameter<double>("maxSubjetMass"),
-						  conf.getParameter<bool>("useSubjetMass")
-						  )
-		);
-	}
+	}	
 	else if (tagAlgo_ == FJ_JHU_TOPTAG ) {
 		fjJHUTopTagger_ = std::auto_ptr<fastjet::JHTopTagger>(
 			new fastjet::JHTopTagger(conf.getParameter<double>("ptFrac"),
@@ -116,7 +108,6 @@ void CATopJetProducer::runAlgorithm( edm::Event& iEvent, const edm::EventSetup&
 	}
 
 	fastjet::CMSTopTagger & CMSTagger = *fjCMSTopTagger_;
-	fastjet::HEPTopTagger & HEPTagger = *fjHEPTopTagger_;
 	fastjet::JHTopTagger & JHUTagger = *fjJHUTopTagger_;
 	fastjet::RestFrameNSubjettinessTagger & NSUBTagger = *fjNSUBTagger_;
 
@@ -129,7 +120,6 @@ void CATopJetProducer::runAlgorithm( edm::Event& iEvent, const edm::EventSetup&
 
 		fastjet::PseudoJet taggedJet;
 		if (tagAlgo_ == FJ_CMS_TOPTAG) taggedJet = CMSTagger.result(*jetIt);
-		else if (tagAlgo_ == FJ_HEP_TOPTAG) taggedJet = HEPTagger.result(*jetIt);
 		else if (tagAlgo_ == FJ_JHU_TOPTAG) taggedJet = JHUTagger.result(*jetIt);
 		else if (tagAlgo_ == FJ_NSUB_TAG) taggedJet = NSUBTagger.result(*jetIt);
 		else cout << "NOT A VALID TAGGING ALGORITHM CHOICE!" << endl;
diff --git a/RecoJets/JetProducers/plugins/CATopJetProducer.h b/RecoJets/JetProducers/plugins/CATopJetProducer.h
index 0d09c30..e942edf 100644
--- a/RecoJets/JetProducers/plugins/CATopJetProducer.h
+++ b/RecoJets/JetProducers/plugins/CATopJetProducer.h
@@ -65,7 +65,6 @@
 #include "RecoJets/JetAlgorithms/interface/CATopJetAlgorithm.h"
 #include "CATopJetProducer.h"
 #include "RecoJets/JetAlgorithms/interface/CMSTopTagger.h"
-#include "RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h"
 
 #include <fastjet/tools/RestFrameNSubjettinessTagger.hh>
 #include "fastjet/SISConePlugin.hh"
@@ -88,7 +87,6 @@ namespace cms
   private:
     std::auto_ptr<CATopJetAlgorithm>        legacyCMSTopTagger_;         /// The algorithm to do the work
     std::auto_ptr<fastjet::CMSTopTagger>     fjCMSTopTagger_;    // The FastJet implementation of the CMS tagger
-    std::auto_ptr<fastjet::HEPTopTagger>     fjHEPTopTagger_;
     std::auto_ptr<fastjet::JHTopTagger>     fjJHUTopTagger_;
     std::auto_ptr<fastjet::RestFrameNSubjettinessTagger>   fjNSUBTagger_;
 
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
new file mode 100644
index 0000000..fb7db32
--- /dev/null
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
@@ -0,0 +1,251 @@
+#include "FWCore/Framework/interface/MakerMacros.h"
+#include "DataFormats/JetReco/interface/HTTTopJetTagInfo.h"
+#include "DataFormats/JetReco/interface/BasicJetCollection.h"
+#include "HTTTopJetProducer.h"
+
+using namespace edm;
+using namespace cms;
+using namespace reco;
+using namespace std;
+
+HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
+       FastjetJetProducer( conf ),
+       multiR_(false),
+       minFatjetPt_(200.),
+       minSubjetPt_(20.),
+       minCandPt_(200.),
+       maxFatjetAbsEta_(2.5),
+       subjetMass_(30.),
+       muCut_(0.8),
+       filtR_(0.3),
+       filtN_(5),       
+       mode_(0),
+       minCandMass_(150.),
+       maxCandMass_(200.),
+       massRatioWidth_(15),
+       minM23Cut_(0.35),
+       minM13Cut_(0.2),
+       maxM13Cut_(1.3),
+       maxR_(1.5),
+       minR_(0.5),
+       verbose_(false )
+{
+  
+  // Read in all the options from the configuration
+  if ( conf.exists("multiR") ) 
+    multiR_ = conf.getParameter<bool>("multiR");
+
+  if ( conf.exists("minFatjetPt") ) 
+    minFatjetPt_ = conf.getParameter<double>("minFatjetPt");
+  
+  if ( conf.exists("minSubjetPt") ) 
+    minSubjetPt_ = conf.getParameter<double>("minSubjetPt");
+  
+  if ( conf.exists("minCandPt") ) 
+    minCandPt_ = conf.getParameter<double>("minCandPt");
+  
+  if ( conf.exists("maxFatjetAbsEta") )
+    maxFatjetAbsEta_ = conf.getParameter<double>("maxFatjetAbsEta");
+  
+  if ( conf.exists("subjetMass") )
+    subjetMass_ = conf.getParameter<double>("subjetMass");
+  
+  if ( conf.exists("muCut") )
+    muCut_ = conf.getParameter<double>("muCut");
+
+  if ( conf.exists("filtR") )
+    filtR_ = conf.getParameter<double>("filtR");
+
+  if ( conf.exists("filtN") )
+    filtN_ = conf.getParameter<int>("filtN");
+  
+  if ( conf.exists("mode") )
+    mode_ = conf.getParameter<int>("mode");
+  
+  if ( conf.exists("minCandMass") )
+    minCandMass_ = conf.getParameter<double>("minCandMass");
+  
+  if ( conf.exists("maxCandMass") )
+    maxCandMass_ = conf.getParameter<double>("maxCandMass");
+  
+  if ( conf.exists("massRatioWidth") )
+    massRatioWidth_ = conf.getParameter<double>("massRatioWidth");
+  
+  if ( conf.exists("minM23Cut") )
+    minM23Cut_ = conf.getParameter<double>("minM23Cut");
+
+  if ( conf.exists("minM13Cut") )
+    minM13Cut_ = conf.getParameter<double>("minM13Cut");
+  
+  if ( conf.exists("maxM13Cut") )
+    maxM13Cut_ = conf.getParameter<double>("maxM13Cut");
+
+  if ( conf.exists("maxR") )
+    maxR_ = conf.getParameter<double>("maxR");
+
+  if ( conf.exists("minR") )
+    minR_ = conf.getParameter<double>("minR");
+
+  
+  if ( conf.exists("verbose") )
+    verbose_ = conf.getParameter<bool>("verbose");
+  
+  // Create the tagger-wrapper
+  produces<HTTTopJetTagInfoCollection>();
+
+  // Signal to the VirtualJetProducer that we have to add HTT information
+  fromHTTTopJetProducer_ = 1;
+
+  if (multiR_){
+    fjMultiRHEPTopTagger_ = std::auto_ptr<fastjet::MultiRHEPTopTagger>(new fastjet::MultiRHEPTopTagger(minSubjetPt_, 
+												       minCandPt_,
+												       subjetMass_, 	    
+												       muCut_, 	
+												       filtR_,
+												       filtN_,
+												       mode_, 		    
+												       minCandMass_, 	    
+												       maxCandMass_, 	    
+												       massRatioWidth_, 	    
+												       minM23Cut_, 	    
+												       minM13Cut_, 	    
+												       maxM13Cut_,
+												       maxR_,
+												       minR_)); 
+  }
+  else{
+    fjHEPTopTagger_ = std::auto_ptr<fastjet::HEPTopTagger>(new fastjet::HEPTopTagger(minSubjetPt_, 
+										     minCandPt_,
+										     subjetMass_, 	    
+										     muCut_, 		    
+										     filtR_,
+										     filtN_,
+										     mode_, 		    
+										     minCandMass_, 	    
+										     maxCandMass_, 	    
+										     massRatioWidth_, 	    
+										     minM23Cut_, 	    
+										     minM13Cut_, 	    
+										     maxM13Cut_)); 
+  }
+
+}
+
+		
+
+
+
+void HTTTopJetProducer::produce(  edm::Event & e, const edm::EventSetup & c ) 
+{
+  FastjetJetProducer::produce(e, c);
+}
+
+void HTTTopJetProducer::runAlgorithm( edm::Event& iEvent, const edm::EventSetup& iSetup)
+{
+
+  if ( !doAreaFastjet_ && !doRhoFastjet_) {
+    fjClusterSeq_ = ClusterSequencePtr( new fastjet::ClusterSequence( fjInputs_, *fjJetDefinition_ ) );
+  } else if (voronoiRfact_ <= 0) {
+    fjClusterSeq_ = ClusterSequencePtr( new fastjet::ClusterSequenceArea( fjInputs_, *fjJetDefinition_ , *fjAreaDefinition_ ) );
+  } else {
+    fjClusterSeq_ = ClusterSequencePtr( new fastjet::ClusterSequenceVoronoiArea( fjInputs_, *fjJetDefinition_ , fastjet::VoronoiAreaSpec(voronoiRfact_) ) );
+  }
+
+  //Run the jet clustering
+  vector<fastjet::PseudoJet> inclusiveJets = fjClusterSeq_->inclusive_jets(minFatjetPt_);
+
+  if ( verbose_ ) cout << "Getting central jets" << endl;
+  // Find the transient central jets
+  vector<fastjet::PseudoJet> centralJets;
+  for (unsigned int i = 0; i < inclusiveJets.size(); i++) {
+    
+    if (inclusiveJets[i].perp() > minFatjetPt_ && fabs(inclusiveJets[i].rapidity()) < maxFatjetAbsEta_) {
+      centralJets.push_back(inclusiveJets[i]);
+    }
+  }
+
+  fastjet::HEPTopTagger & HEPTagger = *fjHEPTopTagger_;
+  fastjet::MultiRHEPTopTagger & MultiRHEPTagger = *fjMultiRHEPTopTagger_;
+
+  vector<fastjet::PseudoJet>::iterator jetIt = centralJets.begin(), centralJetsEnd = centralJets.end();
+  if ( verbose_ )cout<<"Loop over jets"<<endl;
+  for ( ; jetIt != centralJetsEnd; ++jetIt ) {
+    
+    if (verbose_) cout << "CMS FJ jet pt: " << (*jetIt).perp() << endl;
+    
+    fastjet::PseudoJet taggedJet;
+
+    if (multiR_)
+      taggedJet = MultiRHEPTagger.result(*jetIt);
+    else
+      taggedJet = HEPTagger.result(*jetIt);
+
+    if (taggedJet != 0){
+      fjJets_.push_back(taggedJet);           
+    }
+  }
+  
+}
+
+void HTTTopJetProducer::addHTTTopJetTagInfoCollection( edm::Event& iEvent, 
+						       const edm::EventSetup& iSetup,
+						       edm::OrphanHandle<reco::BasicJetCollection> & oh){
+
+
+  // Set up output list
+  auto_ptr<HTTTopJetTagInfoCollection> tagInfos(new HTTTopJetTagInfoCollection() );
+
+  // Loop over jets
+  for (size_t ij=0; ij != fjJets_.size(); ij++){
+
+    HTTTopJetProperties properties;
+    HTTTopJetTagInfo tagInfo;
+
+    // Black magic:
+    // In the standard CA treatment the RefToBase is made from the handle directly
+    // Since we only have a OrphanHandle (the JetCollection is created by this process) 
+    // we have to take the detour via the Ref
+    edm::Ref<reco::BasicJetCollection> ref(oh, ij);  
+    edm::RefToBase<reco::Jet> rtb(ref);  
+    
+    if (multiR_){
+      fastjet::MultiRHEPTopTaggerStructure *s = (fastjet::MultiRHEPTopTaggerStructure*) fjJets_[ij].structure_non_const_ptr();
+      
+      properties.topMass         = s->top_mass();
+      properties.unfilteredMass	 = s->unfiltered_mass();
+      properties.prunedMass	 = s->pruned_mass();
+      properties.fW		 = s->fW();
+      properties.massRatioPassed = s->mass_ratio_passed();     
+      properties.isMultiR	 = 1;
+      properties.Rmin	         = s->R_min();    
+      properties.RminExpected    = 999.;
+      
+      tagInfo.insert(rtb, properties );
+      tagInfos->push_back( tagInfo );
+    }
+    else{      
+      fastjet::HEPTopTaggerStructure *s = (fastjet::HEPTopTaggerStructure*) fjJets_[ij].structure_non_const_ptr();
+      
+      properties.topMass         = s->top_mass();
+      properties.unfilteredMass	 = s->unfiltered_mass();
+      properties.prunedMass	 = s->pruned_mass();
+      properties.fW		 = s->fW();
+      properties.massRatioPassed = s->mass_ratio_passed();
+      
+      // Only needed for MultiR tagger
+      properties.isMultiR	        = 0;
+      properties.Rmin	        = -1.;
+      properties.RminExpected     = -1.;
+      
+      tagInfo.insert(rtb, properties );
+      tagInfos->push_back( tagInfo );
+    }
+  }  
+
+  iEvent.put( tagInfos );
+  
+};
+
+ 
+//define this as a plug-in
+DEFINE_FWK_MODULE(HTTTopJetProducer);
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.h b/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
new file mode 100644
index 0000000..e3cc5bc
--- /dev/null
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
@@ -0,0 +1,140 @@
+#ifndef RecoJets_JetProducers_HTTTopJetProducer_h
+#define RecoJets_JetProducers_HTTTopJetProducer_h
+
+
+/* *********************************************************
+
+
+ * \class CATopJetProducer
+ * Jet producer to produce top jets using the C-A algorithm to break
+ * jets into subjets as described here:
+ * "Top-tagging: A Method for Identifying Boosted Hadronic Tops"
+ * David E. Kaplan, Keith Rehermann, Matthew D. Schwartz, Brock Tweedie
+ * arXiv:0806.0848v1 [hep-ph] 
+
+  \brief Jet producer to run the CATopJetAlgorithm
+
+  \author   Salvatore Rappoccio
+  \version  
+
+         Notes on implementation:
+
+	 Because the BaseJetProducer only allows the user to produce
+	 one jet collection at a time, this algorithm cannot
+	 fit into that paradigm. 
+
+	 All of the "hard" jets are of type BasicJet, since
+	 they are "jets of jets". The subjets will be either
+	 CaloJets, GenJets, etc.
+
+	 In order to avoid a templatization of the entire
+	 EDProducer itself, we only use a templated method
+	 to write out the subjets to the event record,
+	 and to use that information to write out the
+	 hard jets to the event record.
+
+	 This templated method is called "write_outputs". It
+	 relies on a second templated method called "write_specific",
+	 which relies on some template specialization to create
+	 different specific objects (i.e. CaloJets, BasicJets, GenJets, etc). 
+
+ ************************************************************/
+
+
+
+
+#include "FWCore/Framework/interface/Event.h"
+#include "FWCore/Framework/interface/EventSetup.h"
+#include "DataFormats/Common/interface/View.h"
+#include "DataFormats/Common/interface/Handle.h"
+#include "DataFormats/Provenance/interface/ProductID.h"
+#include "FWCore/MessageLogger/interface/MessageLogger.h"
+
+#include "DataFormats/JetReco/interface/CaloJetCollection.h"
+#include "DataFormats/JetReco/interface/GenJetCollection.h"
+#include "DataFormats/JetReco/interface/PFJetCollection.h"
+#include "DataFormats/JetReco/interface/BasicJetCollection.h"
+#include "RecoJets/JetAlgorithms/interface/JetAlgoHelper.h"
+#include "DataFormats/Candidate/interface/CandidateFwd.h"
+#include "DataFormats/Candidate/interface/LeafCandidate.h"
+#include "FWCore/Framework/interface/ESHandle.h"
+#include "Geometry/CaloGeometry/interface/CaloGeometry.h"
+#include "Geometry/Records/interface/CaloGeometryRecord.h"
+
+#include "RecoJets/JetProducers/plugins/FastjetJetProducer.h"
+
+#include "RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h"
+#include "RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h"
+
+#include "fastjet/SISConePlugin.hh"
+
+
+namespace cms
+{
+  class HTTTopJetProducer : public FastjetJetProducer
+  {
+  public:
+
+    HTTTopJetProducer(const edm::ParameterSet& ps);
+
+    virtual ~HTTTopJetProducer() {}
+
+    virtual void produce( edm::Event& iEvent, const edm::EventSetup& iSetup );
+
+    virtual void runAlgorithm( edm::Event& iEvent, const edm::EventSetup& iSetup );
+
+    virtual void addHTTTopJetTagInfoCollection( edm::Event& iEvent, 
+						const edm::EventSetup& iSetup,
+						edm::OrphanHandle<reco::BasicJetCollection> & oh);
+
+
+  private:
+    std::auto_ptr<fastjet::HEPTopTagger>        fjHEPTopTagger_;
+    std::auto_ptr<fastjet::MultiRHEPTopTagger>  fjMultiRHEPTopTagger_;
+
+    // Below are all configurable options. 
+    // Parenthesis indicates if this is enforced by the tagger itself or by the producer
+
+    bool multiR_; // Should the MultiR version of the tagger be used? (producer)
+
+    double minFatjetPt_; // Only process fatjets larger pT with the tagger [GeV] (producer)
+    double minSubjetPt_; // Minimal pT for subjets [GeV] (tagger)
+    double minCandPt_;   // Minimal pT to return a candidate [GeV] (tagger)
+ 
+    double maxFatjetAbsEta_; // Only process fatjets with smaller |eta| with the tagger. (producer)
+
+    double subjetMass_; // Mass above which subjets are further unclustered (tagger)
+    double muCut_; // Mass drop threshold (tagger)
+
+    double filtR_; // maximal filtering radius
+    int filtN_; // number of filtered subjets to use
+    
+    // HEPTopTagger Mode (tagger):
+    // 0: do 2d-plane, return candidate with delta m_top minimal
+    // 1: return candidate with delta m_top minimal IF passes 2d plane
+    // 2: do 2d-plane, return candidate with max dj_sum
+    // 3: return candidate with max dj_sum IF passes 2d plane
+    // 4: return candidate built from leading three subjets after unclustering IF passes 2d plane
+    // Note: Original HTT was mode==1    
+    int mode_; 
+
+    // Top Quark mass window in GeV (tagger)
+    double minCandMass_;
+    double maxCandMass_;
+    
+    double massRatioWidth_; // One sided width of the A-shaped window around m_W/m_top in % (tagger)
+    double minM23Cut_; // minimal value of m23/m123 (tagger)
+    double minM13Cut_; // minimal value of atan(m13/m12) (tagger)
+    double maxM13Cut_; // maximal value of atan(m13/m12) (tagger)
+
+    double maxR_; // maximal fatjet size for MultiR tagger (tagger)
+    double minR_; // minimal fatjet size for MultiR tagger (tagger)
+        
+    bool verbose_;
+
+  };
+
+}
+
+
+#endif
diff --git a/RecoJets/JetProducers/plugins/VirtualJetProducer.cc b/RecoJets/JetProducers/plugins/VirtualJetProducer.cc
index 437f59b..7987e8a 100644
--- a/RecoJets/JetProducers/plugins/VirtualJetProducer.cc
+++ b/RecoJets/JetProducers/plugins/VirtualJetProducer.cc
@@ -10,6 +10,10 @@
 #include "RecoJets/JetProducers/interface/BackgroundEstimator.h"
 #include "RecoJets/JetProducers/interface/VirtualJetProducerHelper.h"
 
+#include "DataFormats/Common/interface/RefProd.h"
+#include "DataFormats/Common/interface/Ref.h"
+#include "DataFormats/Common/interface/RefVector.h"
+
 #include "FWCore/Framework/interface/Event.h"
 #include "FWCore/Framework/interface/EventSetup.h"
 #include "FWCore/Framework/interface/ESHandle.h"
@@ -136,6 +140,7 @@ VirtualJetProducer::VirtualJetProducer(const edm::ParameterSet& iConfig)
   , jetCollInstanceName_ ("")
   , writeCompound_ ( false )
   , verbosity_(0)
+  , fromHTTTopJetProducer_(0)
 {
   anomalousTowerDef_ = std::auto_ptr<AnomalousTower>(new AnomalousTower(iConfig));
 
@@ -834,5 +839,11 @@ void VirtualJetProducer::writeCompoundJets(  edm::Event & iEvent, edm::EventSetu
   }
 
   // put hard jets into event record
-  iEvent.put( jetCollection);
+  // Store the Orphan handle for adding HTT information
+  edm::OrphanHandle<reco::BasicJetCollection>  oh = iEvent.put( jetCollection);
+
+  if (fromHTTTopJetProducer_){
+    addHTTTopJetTagInfoCollection( iEvent, iSetup, oh);
+  }
+
 }
diff --git a/RecoJets/JetProducers/plugins/VirtualJetProducer.h b/RecoJets/JetProducers/plugins/VirtualJetProducer.h
index 8838f38..7214771 100644
--- a/RecoJets/JetProducers/plugins/VirtualJetProducer.h
+++ b/RecoJets/JetProducers/plugins/VirtualJetProducer.h
@@ -12,6 +12,7 @@
 #include "DataFormats/JetReco/interface/PFJet.h"
 #include "DataFormats/JetReco/interface/BasicJet.h"
 #include "DataFormats/JetReco/interface/GenJet.h"
+#include "DataFormats/JetReco/interface/BasicJetCollection.h"
 
 #include "RecoJets/JetProducers/interface/PileUpSubtractor.h"
 #include "RecoJets/JetProducers/interface/AnomalousTower.h"
@@ -118,6 +119,11 @@ protected:
   // has no default. 
   virtual void runAlgorithm( edm::Event& iEvent, const edm::EventSetup& iSetup) = 0;
 
+  // This will allow making the HTTTopJetTagInfoCollection
+  virtual void addHTTTopJetTagInfoCollection( edm::Event& iEvent, 
+					      const edm::EventSetup& iSetup,
+					      edm::OrphanHandle<reco::BasicJetCollection> & oh){};
+ 
   // Do the offset correction. 
   // Only runs if "doPUOffsetCorrection_" is true.  
   void offsetCorrectJets(std::vector<fastjet::PseudoJet> & orphanInput);
@@ -175,7 +181,6 @@ protected:
   bool                  doPUOffsetCorr_;            // add the pileup calculation from offset correction? 
   std::string           puSubtractorName_;
 
-
   std::vector<edm::Ptr<reco::Candidate> > inputs_;  // input candidates [View, PtrVector and CandCollection have limitations]
   reco::Particle::Point           vertex_;          // Primary vertex 
   ClusterSequencePtr              fjClusterSeq_;    // fastjet cluster sequence
@@ -201,5 +205,8 @@ protected:
 
  int                   verbosity_;                 // flag to enable/disable debug output
 
+  bool                  fromHTTTopJetProducer_;   // for running the v2.0 HEPTopTagger
+
+
 private:
   std::auto_ptr<AnomalousTower>   anomalousTowerDef_;  // anomalous tower definition
-- 
1.8.3.1

