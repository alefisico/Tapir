// -*- C++ -*-
//
// Package:    TTH/TTHNtupleAnalyzer
// Class:      TTHNtupleAnalyzer
// 
/**\class TTHNtupleAnalyzer TTHNtupleAnalyzer.cc TTH/TTHNtupleAnalyzer/plugins/TTHNtupleAnalyzer.cc

 Description: A simple N-tuplizer for TTH(->bb), mapping the EDM miniAOD format to a "simple flat ROOT TTree"

 Implementation:
    Based on https://twiki.cern.ch/twiki/bin/view/CMSPublic/WorkBookMiniAOD
    The base event is described by TTHTree, implemented in tth_tree.hh (autogenerated by tree_header.jl based on a specification)
*/
//
// Original Author:  Joosep Pata
//         Created:  Tue, 15 Jul 2014 10:06:28 GMT
//
//


// system include files
#include <memory>
#include <algorithm>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"

#include "DataFormats/PatCandidates/interface/Muon.h"
#include "DataFormats/PatCandidates/interface/Electron.h"
#include "DataFormats/PatCandidates/interface/Tau.h"
#include "DataFormats/PatCandidates/interface/Jet.h"

#include "DataFormats/VertexReco/interface/VertexFwd.h"
#include "DataFormats/VertexReco/interface/Vertex.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"

#include "FWCore/ServiceRegistry/interface/Service.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"

#include "DataFormats/PatCandidates/interface/PackedGenParticle.h"
#include "DataFormats/HepMCCandidate/interface/GenParticle.h"

#include "DataFormats/PatCandidates/interface/MET.h"
#include "DataFormats/PatCandidates/interface/PackedCandidate.h"

#include "SimDataFormats/PileupSummaryInfo/interface/PileupSummaryInfo.h"

//#include "CommonTools/UtilAlgos/interface/PhysObjectMatcher.h"
//#include "CommonTools/UtilAlgos/interface/MatchByDRDPt.h"
//#include "CommonTools/UtilAlgos/interface/MatchLessByDPt.h"
//#include "CommonTools/UtilAlgos/interface/MCMatchSelector.h"

#include "TTH/TTHNtupleAnalyzer/interface/tth_tree.hh"
#include "TStopwatch.h"

#define GENJET_DR 0.5
#define GENJET_REL_DP 0.5

class TTHNtupleAnalyzer : public edm::EDAnalyzer {
    public:
        explicit TTHNtupleAnalyzer(const edm::ParameterSet&);
        ~TTHNtupleAnalyzer();

        static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);


    private:
        virtual void beginJob() override;
        virtual void analyze(const edm::Event&, const edm::EventSetup&) override;
        virtual void endJob() override;
        virtual void finalizeLoop();

        const edm::EDGetTokenT<pat::MuonCollection> muonToken_;
        const edm::EDGetTokenT<pat::ElectronCollection> electronToken_;
        const edm::EDGetTokenT<pat::TauCollection> tauToken_;
        const edm::EDGetTokenT<pat::JetCollection> jetToken_;
        const edm::EDGetTokenT<reco::VertexCollection> vertexToken_;

        const edm::EDGetTokenT<edm::View<reco::GenParticle> > prunedGenToken_;
        const edm::EDGetTokenT<edm::View<pat::PackedGenParticle> > packedGenToken_;
    
        const edm::EDGetTokenT<pat::JetCollection> fatjetToken_;
        const edm::EDGetTokenT<pat::METCollection> metToken_;

        TTHTree* tthtree; 
        const edm::Service<TFileService> fs;
        const bool isMC;

        TStopwatch* sw;
};

TTHTree::TTHTree(TTree* _tree) {
    tree = _tree;
    loop_initialize();
    make_branches();
}

TTHNtupleAnalyzer::TTHNtupleAnalyzer(const edm::ParameterSet& iConfig) :
    muonToken_(consumes<pat::MuonCollection>(iConfig.getParameter<edm::InputTag>("muons"))),
    electronToken_(consumes<pat::ElectronCollection>(iConfig.getParameter<edm::InputTag>("electrons"))),
    tauToken_(consumes<pat::TauCollection>(iConfig.getParameter<edm::InputTag>("taus"))),
    jetToken_(consumes<pat::JetCollection>(iConfig.getParameter<edm::InputTag>("jets"))),
    vertexToken_(consumes<reco::VertexCollection>(iConfig.getParameter<edm::InputTag>("vertices"))),
    prunedGenToken_(consumes<edm::View<reco::GenParticle> >(iConfig.getParameter<edm::InputTag>("pruned"))),
    packedGenToken_(consumes<edm::View<pat::PackedGenParticle> >(iConfig.getParameter<edm::InputTag>("packed"))),
    fatjetToken_(consumes<pat::JetCollection>(iConfig.getParameter<edm::InputTag>("fatjets"))),
    metToken_(consumes<pat::METCollection>(iConfig.getParameter<edm::InputTag>("mets"))),
    tthtree(new TTHTree(fs->make<TTree>("events", "events"))), 
    isMC(iConfig.getParameter<bool>("isMC"))
{
    sw = new TStopwatch();
}


TTHNtupleAnalyzer::~TTHNtupleAnalyzer()
{
    delete sw;
}

void TTHNtupleAnalyzer::finalizeLoop() {
}

// ------------ method called for each event  ------------
void
TTHNtupleAnalyzer::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup)
{
    using namespace edm;
    
    sw->Start();
    tthtree->loop_initialize();

    tthtree->event__id = (unsigned int)iEvent.id().event();
    tthtree->event__run = (unsigned int)iEvent.id().run();
    tthtree->event__lumi = (unsigned int)iEvent.id().luminosityBlock();

//Primary vertices
    edm::Handle<reco::VertexCollection> vertices;
    iEvent.getByToken(vertexToken_, vertices);
    if (vertices->empty()) {
        edm::LogError("loop") << "no vertices found";
        finalizeLoop();
        return;
    }
    const reco::Vertex &PV = vertices->front();
    tthtree->n__pv = vertices->size();
   
//Pileup 
    if (isMC) {
        Handle<std::vector<PileupSummaryInfo>> PupInfo;
        iEvent.getByLabel(edm::InputTag("addPileupInfo"), PupInfo);
        std::vector<PileupSummaryInfo>::const_iterator PVI;
        tthtree->n__pvi = PupInfo->size();
        int n_pu = 0;
        for (PVI = PupInfo->begin(); PVI != PupInfo->end(); ++PVI)
        {
            const int BX = PVI->getBunchCrossing();
            LogDebug("PVI") << n_pu << " BX=" << BX;
            tthtree->pvi__n0[n_pu] = PVI->getPU_NumInteractions();
            tthtree->pvi__bx[n_pu] = BX;
            if (BX == 0)
            {
                tthtree->pvi__ntrue[n_pu] = PVI->getTrueNumInteractions();
            }
            n_pu += 1;
        }
    }

    edm::Handle<pat::MuonCollection> muons;
    iEvent.getByToken(muonToken_, muons);

    Handle<edm::View<reco::GenParticle> > pruned;
    iEvent.getByToken(prunedGenToken_,pruned);
    
    int n__lep = 0;

    int n_mu = 0;
    int n_ele = 0;
    int n_tau = 0;

    int n__jet = 0;

    for (const pat::Muon &x : *muons) {
        LogDebug("muons") << "n_mu=" << n_mu <<
            " pt=" << x.pt() <<
            " dz(PV)=" << x.muonBestTrack()->dz(PV.position()) <<
            " lID=" << x.isLooseMuon() <<
            " tID=" << x.isTightMuon(PV);
        tthtree->lep__eta[n__lep] = x.eta();
        tthtree->lep__pt[n__lep] = x.pt();
        tthtree->lep__phi[n__lep] = x.phi();
        tthtree->lep__mass[n__lep] = x.mass();
        tthtree->lep__id[n__lep] = x.pdgId();
        tthtree->lep__is_tight[n__lep] = x.isTightMuon(PV);
        tthtree->lep__is_loose[n__lep] = x.isLooseMuon();

        if (x.muonBestTrack().isNonnull()) {
            tthtree->lep__dxy[n__lep] = x.muonBestTrack()->dxy(PV.position()); 
            tthtree->lep__dz[n__lep] = x.muonBestTrack()->dz(PV.position());
        } else {
            edm::LogWarning("muon") << "gsfTrack is 0 for n_mu=" << n_mu;
        } 
        if (isMC) { 
            if (x.genParticle() != NULL) { 
                tthtree->gen_lep__eta[n__lep] = x.genParticle()->eta();
                tthtree->gen_lep__pt[n__lep] = x.genParticle()->pt();
                tthtree->gen_lep__phi[n__lep] = x.genParticle()->phi();
                tthtree->gen_lep__mass[n__lep] = x.genParticle()->mass();
                tthtree->gen_lep__id[n__lep] = x.genParticle()->pdgId();
            } else {
                LogDebug("muons") << "genParticle()==0 for muon n_mu=" << n_mu;
            }
        }
        n_mu += 1;
        n__lep += 1;
    }

    edm::Handle<pat::ElectronCollection> electrons;
    iEvent.getByToken(electronToken_, electrons);
    for (const pat::Electron &x : *electrons) {
        LogDebug("electrons") << "n_ele=" << n_ele <<
            " pt=" << x.pt();
        tthtree->lep__eta[n__lep] = x.eta();
        tthtree->lep__pt[n__lep] = x.pt();
        tthtree->lep__phi[n__lep] = x.phi();
        tthtree->lep__mass[n__lep] = x.mass();
        tthtree->lep__id[n__lep] = x.pdgId();
        
        //tthtree->lep__is_tight[n__lep] = x.isTightElectron(PV);
        //tthtree->lep__is_loose[n__lep] = x.isLooseElectron();
        if (x.gsfTrack().isNonnull()) {
            tthtree->lep__dxy[n__lep] = x.gsfTrack()->dxy(PV.position()); 
            tthtree->lep__dz[n__lep] = x.gsfTrack()->dz(PV.position());
        } else {
            edm::LogWarning("electron") << "gsfTrack is 0 for n_ele=" << n_ele;
        } 
        if (isMC) { 
            if (x.genParticle() != NULL) { 
                tthtree->gen_lep__eta[n__lep] = x.genParticle()->eta();
                tthtree->gen_lep__pt[n__lep] = x.genParticle()->pt();
                tthtree->gen_lep__phi[n__lep] = x.genParticle()->phi();
                tthtree->gen_lep__mass[n__lep] = x.genParticle()->mass();
                tthtree->gen_lep__id[n__lep] = x.genParticle()->pdgId();
            } else {
                LogDebug("electron") << "genParticle()==0 for electron n_ele=" << n_ele;
            }
        }
        n_ele += 1;
        n__lep += 1;
    }

    edm::Handle<pat::TauCollection> taus;
    iEvent.getByToken(tauToken_, taus);
    for (const pat::Tau &x : *taus) {
        LogDebug("taus") << "n_tau=" << n_tau <<
            " pt=" << x.pt();
        tthtree->lep__eta[n__lep] = x.eta();
        tthtree->lep__pt[n__lep] = x.pt();
        tthtree->lep__phi[n__lep] = x.phi();
        tthtree->lep__mass[n__lep] = x.mass();
        tthtree->lep__id[n__lep] = x.pdgId();
        
        //tthtree->lep__is_tight[n__lep] = x.isTightElectron(PV);
        //tthtree->lep__is_loose[n__lep] = x.isLooseElectron();
        if (x.leadTrack().isNonnull()) {
            tthtree->lep__dxy[n__lep] = x.leadTrack()->dxy(PV.position()); 
            tthtree->lep__dz[n__lep] = x.leadTrack()->dz(PV.position());
        } else {
            edm::LogWarning("tau") << "leadTrack is 0 for n_tau=" << n_tau;
        } 
       
        if (isMC) { 
            if (x.genParticle()!=NULL) { 
                tthtree->gen_lep__eta[n__lep] = x.genParticle()->eta();
                tthtree->gen_lep__pt[n__lep] = x.genParticle()->pt();
                tthtree->gen_lep__phi[n__lep] = x.genParticle()->phi();
                tthtree->gen_lep__mass[n__lep] = x.genParticle()->mass();
                tthtree->gen_lep__id[n__lep] = x.genParticle()->pdgId();
            } else {
                LogDebug("taus") << "genParticle()==0 for tau n_tau=" << n_tau;
            }
        }
        n_tau += 1;
        n__lep += 1;
    }
    
    edm::Handle<pat::JetCollection> jets;
    iEvent.getByToken(jetToken_, jets);
    for (const pat::Jet &x : *jets) {
        LogDebug("jets") << "n__jet=" << n__jet <<
            " pt=" << x.pt();
        tthtree->jet__eta[n__jet] = x.eta();
        tthtree->jet__pt[n__jet] = x.pt();
        tthtree->jet__phi[n__jet] = x.phi();
        tthtree->jet__mass[n__jet] = x.mass();
        tthtree->jet__bd_csv[n__jet] = x.bDiscriminator("combinedSecondaryVertexBJetTags");
        tthtree->jet__id[n__jet] = x.partonFlavour();
        
        if (isMC) { 
            if (x.genParticle()!=NULL) { 
                tthtree->gen_jet__eta[n__jet] = x.genParticle()->eta();
                tthtree->gen_jet__pt[n__jet] = x.genParticle()->pt();
                tthtree->gen_jet__phi[n__jet] = x.genParticle()->phi();
                tthtree->gen_jet__mass[n__jet] = x.genParticle()->mass();
                tthtree->gen_jet__id[n__jet] = x.genParticle()->pdgId();
            } else {
                LogDebug("jets") << "genParticle()==0 for jet n__jet=" << n__jet << " pt=" << x.pt() << " eta=" << x.eta() << " phi=" << x.phi();
                std::vector<const reco::GenParticle*> matched;
                for (auto& p : *pruned) {
                    const float dr = sqrt(reco::deltaR2(x.p4(), p.p4()));
                    const float rel_dp = fabs(x.pt()-p.pt())/p.pt();
                    //LogDebug("jets") << "dR=" << dr << " rel_dp=" << rel_dp;
                    if (dr<GENJET_DR && rel_dp<GENJET_REL_DP) {
                        matched.push_back(&p);
                    }
                }
 
                auto sortf = [&x](const reco::GenParticle* a, const reco::GenParticle* b) -> bool {
                    return (reco::deltaR2(x.p4(), a->p4()) < reco::deltaR2(x.p4(), b->p4()));
                };

                std::sort(matched.begin(), matched.end(), sortf);

                LogDebug("jets") << "dR < " << GENJET_DR << " matched " << matched.size();
                if (matched.size()>0) {
                    const reco::GenParticle* gp = matched[0];
                    LogDebug("jets") << "best match" << " pt=" << gp->pt() << " eta=" << gp->eta() << " phi=" << gp->phi();
                    tthtree->gen_jet__eta[n__jet] = gp->eta();
                    tthtree->gen_jet__pt[n__jet] = gp->pt();
                    tthtree->gen_jet__phi[n__jet] = gp->phi();
                    tthtree->gen_jet__mass[n__jet] = gp->mass();
                    tthtree->gen_jet__id[n__jet] = gp->pdgId();
                }
            }
        }
        n_ele += 1;
        n__jet += 1;
    }

    if (n__lep>=N_MAX) {
        edm::LogError("N_MAX") << "Exceeded vector N_MAX with n__lep: " << n__lep << ">=> " << N_MAX;
        throw std::exception();
    }

    if (n__jet>=N_MAX) {
        edm::LogError("N_MAX") << "Exceeded vector N_MAX with n__jet: " << n__jet << ">=> " << N_MAX;
        throw std::exception();
    }


    edm::Handle<pat::JetCollection> fatjets;
    iEvent.getByToken(fatjetToken_, fatjets);
    //for (const pat::Jet &j : *fatjets) {
    //}
 
    edm::Handle<pat::METCollection> mets;
    iEvent.getByToken(metToken_, mets);
    const pat::MET &met = mets->front();
    tthtree->met__pt = met.pt();
    tthtree->met__phi = met.phi();

    if (isMC) {
        tthtree->met__pt__en_up = met.shiftedPt(pat::MET::JetEnUp);
        tthtree->met__pt__en_down = met.shiftedPt(pat::MET::JetEnDown);
        tthtree->gen_met__pt = met.genMET()->pt();
        tthtree->gen_met__phi = met.genMET()->phi();
    }

    tthtree->n__lep = n__lep;
    tthtree->n__gen_lep = n__lep;
    tthtree->n__jet = n__jet;
    tthtree->n__gen_jet = n__jet;

    sw->Stop();
    tthtree->debug__time1r = sw->RealTime();
    tthtree->debug__time1c = sw->CpuTime();
    LogDebug("time") << tthtree->debug__time1r << " " << tthtree->debug__time1c;
    tthtree->tree->Fill();
}

// ------------ method called once each job just before starting event loop  ------------
void 
TTHNtupleAnalyzer::beginJob()
{
}

// ------------ method called once each job just after ending the event loop  ------------
void 
TTHNtupleAnalyzer::endJob() 
{
}

// ------------ method called when starting to processes a run  ------------
/*
void 
TTHNtupleAnalyzer::beginRun(edm::Run const&, edm::EventSetup const&)
{
}
*/

// ------------ method called when ending the processing of a run  ------------
/*
void 
TTHNtupleAnalyzer::endRun(edm::Run const&, edm::EventSetup const&)
{
}
*/

// ------------ method called when starting to processes a luminosity block  ------------
/*
void 
TTHNtupleAnalyzer::beginLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
}
*/

// ------------ method called when ending the processing of a luminosity block  ------------
/*
void 
TTHNtupleAnalyzer::endLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
}
*/

// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
void
TTHNtupleAnalyzer::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
  //The following says we do not know what parameters are allowed so do no validation
  // Please change this to state exactly what you do use, even if it is no parameters
  edm::ParameterSetDescription desc;
  desc.setUnknown();
  descriptions.addDefault(desc);
}

//define this as a plug-in
DEFINE_FWK_MODULE(TTHNtupleAnalyzer);
