// -*- C++ -*-
//
// Package:    TTH/TTHNtupleAnalyzer
// Class:      TTHNtupleAnalyzer
// 
/**\class TTHNtupleAnalyzer TTHNtupleAnalyzer.cc TTH/TTHNtupleAnalyzer/plugins/TTHNtupleAnalyzer.cc

 Description: A simple N-tuplizer for TTH(->bb), mapping the EDM miniAOD format to a "simple flat ROOT TTree"

 Implementation:
    Based on https://twiki.cern.ch/twiki/bin/view/CMSPublic/WorkBookMiniAOD
    The base event is described by TTHTree, implemented in tth_tree.hh (autogenerated by tree_header.jl based on a specification)
*/
//
// Original Author:  Joosep Pata
//         Created:  Tue, 15 Jul 2014 10:06:28 GMT
//
//


// system include files
#include <memory>
#include <algorithm>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"

#include "DataFormats/PatCandidates/interface/Muon.h"
#include "DataFormats/PatCandidates/interface/Electron.h"
#include "DataFormats/PatCandidates/interface/Tau.h"
#include "DataFormats/PatCandidates/interface/Jet.h"

#include "DataFormats/VertexReco/interface/VertexFwd.h"
#include "DataFormats/VertexReco/interface/Vertex.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"

#include "FWCore/ServiceRegistry/interface/Service.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"

#include "DataFormats/PatCandidates/interface/PackedGenParticle.h"
#include "DataFormats/HepMCCandidate/interface/GenParticle.h"

#include "DataFormats/PatCandidates/interface/MET.h"
#include "DataFormats/PatCandidates/interface/PackedCandidate.h"

#include "SimDataFormats/PileupSummaryInfo/interface/PileupSummaryInfo.h"

#include "SimDataFormats/GeneratorProducts/interface/LHEEventProduct.h"

//#include "CommonTools/UtilAlgos/interface/PhysObjectMatcher.h"
//#include "CommonTools/UtilAlgos/interface/MatchByDRDPt.h"
//#include "CommonTools/UtilAlgos/interface/MatchLessByDPt.h"
//#include "CommonTools/UtilAlgos/interface/MCMatchSelector.h"

#include "TTH/TTHNtupleAnalyzer/interface/tth_tree.hh"
#include "TStopwatch.h"

#define CANDPRINT(x) " pt=" << x.pt() << " eta=" << x.eta() << " phi=" << x.phi() << " id=" << x.pdgId() << " st=" << x.status()
#define PCANDPRINT(x) " pt=" << x->pt() << " eta=" << x->eta() << " phi=" << x->phi() << " id=" << x->pdgId() << " st=" << x->status()
#define GENJET_DR 0.5
#define GENJET_REL_DP 0.5

template <typename T, typename R>
std::vector<R> to_ptrvec(T coll) {
    std::vector<R> ret;
    for (auto e : coll) {
        assert(&e != NULL);
        ret.push_back((R)&e);
    }
    return ret;
}

template <typename T>
bool sort_by_pt(T a, T b) {
    assert(a!=NULL && b!=NULL);
    return (a->pt() > b->pt());
};

class TTHNtupleAnalyzer : public edm::EDAnalyzer {
    public:
        explicit TTHNtupleAnalyzer(const edm::ParameterSet&);
        ~TTHNtupleAnalyzer();

        static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);


    private:
        virtual void beginJob() override;
        virtual void analyze(const edm::Event&, const edm::EventSetup&) override;
        virtual void endJob() override;
        virtual void finalizeLoop();

        const edm::EDGetTokenT<pat::MuonCollection> muonToken_;
        const edm::EDGetTokenT<pat::ElectronCollection> electronToken_;
        const edm::EDGetTokenT<pat::TauCollection> tauToken_;
        const edm::EDGetTokenT<pat::JetCollection> jetToken_;
        const edm::EDGetTokenT<reco::VertexCollection> vertexToken_;

        const edm::EDGetTokenT<edm::View<reco::GenParticle> > prunedGenToken_;
        const edm::EDGetTokenT<edm::View<pat::PackedGenParticle> > packedGenToken_;
    
        const edm::EDGetTokenT<pat::JetCollection> fatjetToken_;
        const edm::EDGetTokenT<pat::METCollection> metToken_;
        
        const edm::EDGetTokenT<LHEEventProduct> lheToken_;

        TTHTree* tthtree; 
        const edm::Service<TFileService> fs;
        const bool isMC;

        TStopwatch* sw;
};

TTHTree::TTHTree(TTree* _tree) {
    tree = _tree;
    loop_initialize();
    make_branches();
}

TTHNtupleAnalyzer::TTHNtupleAnalyzer(const edm::ParameterSet& iConfig) :
    muonToken_(consumes<pat::MuonCollection>(iConfig.getParameter<edm::InputTag>("muons"))),
    electronToken_(consumes<pat::ElectronCollection>(iConfig.getParameter<edm::InputTag>("electrons"))),
    tauToken_(consumes<pat::TauCollection>(iConfig.getParameter<edm::InputTag>("taus"))),
    jetToken_(consumes<pat::JetCollection>(iConfig.getParameter<edm::InputTag>("jets"))),
    vertexToken_(consumes<reco::VertexCollection>(iConfig.getParameter<edm::InputTag>("vertices"))),
    prunedGenToken_(consumes<edm::View<reco::GenParticle> >(iConfig.getParameter<edm::InputTag>("pruned"))),
    packedGenToken_(consumes<edm::View<pat::PackedGenParticle> >(iConfig.getParameter<edm::InputTag>("packed"))),
    fatjetToken_(consumes<pat::JetCollection>(iConfig.getParameter<edm::InputTag>("fatjets"))),
    metToken_(consumes<pat::METCollection>(iConfig.getParameter<edm::InputTag>("mets"))),
    lheToken_(consumes<LHEEventProduct>(iConfig.getParameter<edm::InputTag>("lhe"))),
    tthtree(new TTHTree(fs->make<TTree>("events", "events"))), 
    isMC(iConfig.getParameter<bool>("isMC"))
{
    sw = new TStopwatch();
}


TTHNtupleAnalyzer::~TTHNtupleAnalyzer()
{
    delete sw;
}

void TTHNtupleAnalyzer::finalizeLoop() {
}

// ------------ method called for each event  ------------
void
TTHNtupleAnalyzer::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup)
{
    using namespace edm;
    
    sw->Start();
    tthtree->loop_initialize();

    tthtree->event__id = (unsigned int)iEvent.id().event();
    tthtree->event__run = (unsigned int)iEvent.id().run();
    tthtree->event__lumi = (unsigned int)iEvent.id().luminosityBlock();

//Primary vertices
    edm::Handle<reco::VertexCollection> vertices;
    iEvent.getByToken(vertexToken_, vertices);
    if (vertices->empty()) {
        edm::LogError("loop") << "no vertices found";
        finalizeLoop();
        return;
    }
    const reco::Vertex &PV = vertices->front();
    tthtree->n__pv = vertices->size();
   
//Pileup 
    if (isMC) {
        Handle<std::vector<PileupSummaryInfo>> PupInfo;
        iEvent.getByLabel(edm::InputTag("addPileupInfo"), PupInfo);
        std::vector<PileupSummaryInfo>::const_iterator PVI;
        tthtree->n__pvi = PupInfo->size();
        int n_pu = 0;
        for (PVI = PupInfo->begin(); PVI != PupInfo->end(); ++PVI)
        {
            const int BX = PVI->getBunchCrossing();
            LogDebug("PVI") << n_pu << " BX=" << BX;
            tthtree->pvi__n0[n_pu] = PVI->getPU_NumInteractions();
            tthtree->pvi__bx[n_pu] = BX;
            if (BX == 0)
            {
                tthtree->pvi__ntrue[n_pu] = PVI->getTrueNumInteractions();
            }
            n_pu += 1;
        }
    }

    edm::Handle<pat::MuonCollection> muons;
    iEvent.getByToken(muonToken_, muons);

    Handle<edm::View<reco::GenParticle> > pruned;
    iEvent.getByToken(prunedGenToken_,pruned);
    
    int n__lep = 0;

    int n_mu = 0;
    int n_ele = 0;
    int n_tau = 0;

    int n__jet = 0;

    for (const pat::Muon &x : *muons) {
        LogDebug("muons") << "n_mu=" << n_mu <<
            " pt=" << x.pt() <<
            " dz(PV)=" << x.muonBestTrack()->dz(PV.position()) <<
            " lID=" << x.isLooseMuon() <<
            " tID=" << x.isTightMuon(PV);
        tthtree->lep__eta[n__lep] = x.eta();
        tthtree->lep__pt[n__lep] = x.pt();
        tthtree->lep__phi[n__lep] = x.phi();
        tthtree->lep__mass[n__lep] = x.mass();
        tthtree->lep__id[n__lep] = x.pdgId();
        tthtree->lep__is_tight[n__lep] = x.isTightMuon(PV);
        tthtree->lep__is_loose[n__lep] = x.isLooseMuon();

        if (x.muonBestTrack().isNonnull()) {
            tthtree->lep__dxy[n__lep] = x.muonBestTrack()->dxy(PV.position()); 
            tthtree->lep__dz[n__lep] = x.muonBestTrack()->dz(PV.position());
        } else {
            edm::LogWarning("muon") << "gsfTrack is 0 for n_mu=" << n_mu;
        } 
        if (isMC) { 
            const reco::GenParticle* gp = x.genParticle();
            if (x.genParticle() != NULL) { 
                tthtree->gen_lep__eta[n__lep] = gp->eta();
                tthtree->gen_lep__pt[n__lep] = gp->pt();
                tthtree->gen_lep__phi[n__lep] = gp->phi();
                tthtree->gen_lep__mass[n__lep] = gp->mass();
                tthtree->gen_lep__id[n__lep] = gp->pdgId();
                tthtree->gen_lep__status[n__lep] = gp->status();
            } else {
                LogDebug("muons") << "genParticle()==0 for muon n_mu=" << n_mu;
            }
        }
        n_mu += 1;
        n__lep += 1;
    }

    edm::Handle<pat::ElectronCollection> electrons;
    iEvent.getByToken(electronToken_, electrons);
    for (const pat::Electron &x : *electrons) {
        LogDebug("electrons") << "n_ele=" << n_ele <<
            " pt=" << x.pt();
        tthtree->lep__eta[n__lep] = x.eta();
        tthtree->lep__pt[n__lep] = x.pt();
        tthtree->lep__phi[n__lep] = x.phi();
        tthtree->lep__mass[n__lep] = x.mass();
        tthtree->lep__id[n__lep] = x.pdgId();
        
        //tthtree->lep__is_tight[n__lep] = x.isTightElectron(PV);
        //tthtree->lep__is_loose[n__lep] = x.isLooseElectron();
        if (x.gsfTrack().isNonnull()) {
            tthtree->lep__dxy[n__lep] = x.gsfTrack()->dxy(PV.position()); 
            tthtree->lep__dz[n__lep] = x.gsfTrack()->dz(PV.position());
        } else {
            edm::LogWarning("electron") << "gsfTrack is 0 for n_ele=" << n_ele;
        } 
        if (isMC) { 
            const reco::GenParticle* gp = x.genParticle();
            if (gp != NULL) { 
                tthtree->gen_lep__eta[n__lep] = gp->eta();
                tthtree->gen_lep__pt[n__lep] = gp->pt();
                tthtree->gen_lep__phi[n__lep] = gp->phi();
                tthtree->gen_lep__mass[n__lep] = gp->mass();
                tthtree->gen_lep__id[n__lep] = gp->pdgId();
                tthtree->gen_lep__status[n__lep] = gp->status();
            } else {
                LogDebug("electron") << "genParticle()==0 for electron n_ele=" << n_ele;
            }
        }
        n_ele += 1;
        n__lep += 1;
    }

    edm::Handle<pat::TauCollection> taus;
    iEvent.getByToken(tauToken_, taus);
    for (const pat::Tau &x : *taus) {
        LogDebug("taus") << "n_tau=" << n_tau <<
            " pt=" << x.pt();
        tthtree->lep__eta[n__lep] = x.eta();
        tthtree->lep__pt[n__lep] = x.pt();
        tthtree->lep__phi[n__lep] = x.phi();
        tthtree->lep__mass[n__lep] = x.mass();
        tthtree->lep__id[n__lep] = x.pdgId();
        
        tthtree->lep__ch_iso[n__lep] = x.chargedHadronIso();
        tthtree->lep__puch_iso[n__lep] = x.puChargedHadronIso();
        tthtree->lep__ec_iso[n__lep] = x.ecalIso();
        tthtree->lep__hc_iso[n__lep] = x.hcalIso();
        tthtree->lep__p_iso[n__lep] = x.particleIso();
        tthtree->lep__ph_iso[n__lep] = x.photonIso();
        
        //tthtree->lep__is_tight[n__lep] = x.isTightElectron(PV);
        //tthtree->lep__is_loose[n__lep] = x.isLooseElectron();
        if (x.leadTrack().isNonnull()) {
            tthtree->lep__dxy[n__lep] = x.leadTrack()->dxy(PV.position()); 
            tthtree->lep__dz[n__lep] = x.leadTrack()->dz(PV.position());
        } else {
            LogDebug("tau") << "leadTrack is 0 for n_tau=" << n_tau;
        } 
      
        const reco::GenParticle* gp = x.genParticle();
        if (isMC) { 
            if (gp != NULL) { 
                tthtree->gen_lep__eta[n__lep] = gp->eta();
                tthtree->gen_lep__pt[n__lep] = gp->pt();
                tthtree->gen_lep__phi[n__lep] = gp->phi();
                tthtree->gen_lep__mass[n__lep] = gp->mass();
                tthtree->gen_lep__id[n__lep] = gp->pdgId();
                tthtree->gen_lep__status[n__lep] = gp->status();
            } else {
                LogDebug("taus") << "genParticle()==0 for tau n_tau=" << n_tau;
            }
        }
        n_tau += 1;
        n__lep += 1;
    }
                
    edm::Handle<pat::JetCollection> jets;
    iEvent.getByToken(jetToken_, jets);

    //sort jets by pt
    //auto jetps = to_ptrvec<const std::vector<pat::Jet>&, const pat::Jet*>(*jets);
    //std::sort(jetps.begin(), jetps.end(), sort_by_pt<const pat::Jet*>);
    
    for (auto x : *jets) {
        //assert(_x != NULL);
        //const pat::Jet& x = *_x;
        LogDebug("jets") << "n__jet=" << n__jet << CANDPRINT(x);
        tthtree->jet__eta[n__jet] = x.eta();
        tthtree->jet__pt[n__jet] = x.pt();
        tthtree->jet__phi[n__jet] = x.phi();
        tthtree->jet__mass[n__jet] = x.mass();
        tthtree->jet__bd_csv[n__jet] = x.bDiscriminator("combinedSecondaryVertexBJetTags");
        tthtree->jet__id[n__jet] = x.partonFlavour();
        
        tthtree->jet__nh_e[n__jet] = x.neutralHadronEnergy();
        tthtree->jet__ne_e[n__jet] = x.neutralEmEnergy();
        tthtree->jet__ch_e[n__jet] = x.chargedHadronEnergy();
        tthtree->jet__ce_e[n__jet] = x.chargedEmEnergy();
        tthtree->jet__mu_e[n__jet] = x.muonEnergy();
        tthtree->jet__el_e[n__jet] = x.electronEnergy();
        tthtree->jet__ph_e[n__jet] = x.photonEnergy();
       


        if (isMC) { 
            //generated parton
            const reco::GenParticle* gp = x.genParticle();
            if (gp == NULL) { 
                LogDebug("jets") << "n__jet=" << n__jet << " does not have genParticle(), doing dR/dP matching"; 
                std::vector<const reco::GenParticle*> matched;
                for (auto& p : *pruned) {
                    const float dr = sqrt(reco::deltaR2(x.p4(), p.p4()));
                    const float rel_dp = fabs(x.pt()-p.pt())/p.pt();
                    //LogDebug("jets") << "dR=" << dr << " rel_dp=" << rel_dp;
                    if (dr<GENJET_DR && rel_dp<GENJET_REL_DP) {
                        matched.push_back(&p);
                    }
                }
                LogDebug("jets") << "dR < " << GENJET_DR << " matched " << matched.size();
                
                //sort genparticles by dR(recojet, genparticle) ascending 
                auto sortf = [&x](const reco::GenParticle* a, const reco::GenParticle* b) -> bool {
                    return (reco::deltaR2(x.p4(), a->p4()) < reco::deltaR2(x.p4(), b->p4()));
                };

                std::sort(matched.begin(), matched.end(), sortf);
                //if we had at least one match, choose lowest dR
                if (matched.size()>0) {
                    gp = matched[0];
                    LogDebug("jets") << "best match " << PCANDPRINT(gp);
                }
            }

            if (gp != NULL) {
                tthtree->gen_jet_parton__eta[n__jet] = gp->eta();
                tthtree->gen_jet_parton__pt[n__jet] = gp->pt();
                tthtree->gen_jet_parton__phi[n__jet] = gp->phi();
                tthtree->gen_jet_parton__mass[n__jet] = gp->mass();
                tthtree->gen_jet_parton__id[n__jet] = gp->pdgId();
                tthtree->gen_jet_parton__status[n__jet] = gp->status();

                for (auto _m : gp->motherRefVector()) {
                    if (_m.isNull()) {
                        continue;
                    }
                    auto& m = *_m;
                    LogDebug("jets") << "jet " << n__jet << " genParticle mother " << CANDPRINT(m); 
                }
            } else {
                LogDebug("jets") << "jet " << n__jet << " genParticle==0"; 
            }
 
            //generator-level jet
            const reco::GenJet* gj = x.genJet();
            if (gj != NULL) { 
                tthtree->gen_jet__eta[n__jet] = gj->eta();
                tthtree->gen_jet__pt[n__jet] = gj->pt();
                tthtree->gen_jet__phi[n__jet] = gj->phi();
                tthtree->gen_jet__mass[n__jet] = gj->mass();
                tthtree->gen_jet__id[n__jet] = gj->pdgId();
                tthtree->gen_jet__status[n__jet] = gj->status();
                
                //FIXME: do we want to save the constituents or just perform some maths on it?
                unsigned int i = 0; 
                for (auto cn : gj->getGenConstituents()) {
                    if (i >= M_MAX || n__jet >= M_MAX) {
                        LogDebug("jets") << "constituent " << i << " loop iteration exceeded M_MAX=" << M_MAX;
                        break; 
                    }
                    if (cn != NULL) {
                        LogDebug("jets") << "constituent " << i << " is null";
                        continue;
                    } else {
                        LogDebug("jets") << "constituent " << i << " is not null";
                    }
                    LogDebug("jets") << "constituent " << i << cn->pt();
                    LogDebug("jets") << "constituent " << i << " " << PCANDPRINT(cn);
                    tthtree->jet__c_eta[n__jet][i] = cn->eta();
                    tthtree->jet__c_pt[n__jet][i] = cn->pt();
                    tthtree->jet__c_phi[n__jet][i] = cn->phi();
                    tthtree->jet__c_id[n__jet][i] = cn->pdgId();
                    LogDebug("jets") << "constituent " << i << " end of loop";
                    i += 1;
                }
        

            } else {
                LogDebug("jet") << "jet " << n__jet << " did not have genJet";
            }
        }
        n__jet += 1;
    }

    if (n__lep>=N_MAX) {
        edm::LogError("N_MAX") << "Exceeded vector N_MAX with n__lep: " << n__lep << ">=> " << N_MAX;
        throw std::exception();
    }

    if (n__jet>=N_MAX) {
        edm::LogError("N_MAX") << "Exceeded vector N_MAX with n__jet: " << n__jet << ">=> " << N_MAX;
        throw std::exception();
    }


    edm::Handle<pat::JetCollection> fatjets;
    iEvent.getByToken(fatjetToken_, fatjets);
    //for (const pat::Jet &j : *fatjets) {
    //}
 
    edm::Handle<pat::METCollection> mets;
    iEvent.getByToken(metToken_, mets);
    const pat::MET &met = mets->front();
    tthtree->met__pt = met.pt();
    tthtree->met__phi = met.phi();

    if (isMC) {
        tthtree->met__pt__en_up = met.shiftedPt(pat::MET::JetEnUp);
        tthtree->met__pt__en_down = met.shiftedPt(pat::MET::JetEnDown);
        tthtree->gen_met__pt = met.genMET()->pt();
        tthtree->gen_met__phi = met.genMET()->phi();
    }

    //get the LHE gen-level stuff
    //code from LB
    if (isMC) {
        edm::Handle<LHEEventProduct> lhe;
        iEvent.getByToken(lheToken_, lhe);

        const lhef::HEPEUP hepeup_ = lhe->hepeup();
        const std::vector<lhef::HEPEUP::FiveVector> pup_ = hepeup_.PUP; // px, py, pz, E, M        
   
        double lheHT = 0.0;
        unsigned int lheNj = 0;
        unsigned int countBquarks=0, countCquarks=0, countUDSquarks=0, countGquarks=0, countExtraPartons=0; 
        for (unsigned int i=0; i<pup_.size(); ++i) {
            int id=hepeup_.IDUP[i]; //pdgId                                                                                 
            int status = hepeup_.ISTUP[i];
            int idabs=TMath::Abs(id);
            
             // gluons and quarks
            if(status == 1 && ((idabs == 21) || (idabs > 0 && idabs < 7))) {                      
                // first entry is px, second py
                lheHT += TMath::Sqrt( TMath::Power(hepeup_.PUP[i][0],2) + TMath::Power(hepeup_.PUP[i][1],2) );
                lheNj++;
            }

            if ( hepeup_.ISTUP[i] >= 0 && status == 1 ) {
                if (!(hepeup_.MOTHUP[i].first !=1 && hepeup_.MOTHUP[i].second !=2)) {
                    if(idabs==5  ) countBquarks++;
                    if(idabs==4  ) countCquarks++;
                    if(idabs<=3 && idabs>=1 ) countUDSquarks++;
                    if(idabs==21  ) countGquarks++;
                    if(idabs==21 || (idabs>=1 && idabs<=5)) countExtraPartons++;
                }
            }
        }
        tthtree->lhe__ht = lheHT;
        tthtree->lhe__n_j = lheNj;
        tthtree->lhe__n_b = countBquarks;
        tthtree->lhe__n_c = countCquarks;
        tthtree->lhe__n_l = countUDSquarks;
        tthtree->lhe__n_g = countGquarks;
        tthtree->lhe__n_e = countExtraPartons;
    }

    tthtree->n__lep = n__lep;
    tthtree->n__gen_lep = n__lep;
    tthtree->n__jet = n__jet;
    tthtree->n__gen_jet = n__jet;

    sw->Stop();
    tthtree->debug__time1r = sw->RealTime();
    tthtree->debug__time1c = sw->CpuTime();
    LogDebug("time") << tthtree->debug__time1r << " " << tthtree->debug__time1c;
    tthtree->tree->Fill();
}

// ------------ method called once each job just before starting event loop  ------------
void 
TTHNtupleAnalyzer::beginJob()
{
}

// ------------ method called once each job just after ending the event loop  ------------
void 
TTHNtupleAnalyzer::endJob() 
{
}

// ------------ method called when starting to processes a run  ------------
/*
void 
TTHNtupleAnalyzer::beginRun(edm::Run const&, edm::EventSetup const&)
{
}
*/

// ------------ method called when ending the processing of a run  ------------
/*
void 
TTHNtupleAnalyzer::endRun(edm::Run const&, edm::EventSetup const&)
{
}
*/

// ------------ method called when starting to processes a luminosity block  ------------
/*
void 
TTHNtupleAnalyzer::beginLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
}
*/

// ------------ method called when ending the processing of a luminosity block  ------------
/*
void 
TTHNtupleAnalyzer::endLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
}
*/

// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
void
TTHNtupleAnalyzer::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
  //The following says we do not know what parameters are allowed so do no validation
  // Please change this to state exactly what you do use, even if it is no parameters
  edm::ParameterSetDescription desc;
  desc.setUnknown();
  descriptions.addDefault(desc);
}

//define this as a plug-in
DEFINE_FWK_MODULE(TTHNtupleAnalyzer);
