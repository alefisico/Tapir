// -*- C++ -*-
//
// Package:    TTH/TTHNtupleAnalyzer
// Class:      TTHNtupleAnalyzer
//
/**\class TTHNtupleAnalyzer TTHNtupleAnalyzer.cc TTH/TTHNtupleAnalyzer/plugins/TTHNtupleAnalyzer.cc

 Description: A simple N-tuplizer for TTH(->bb), mapping the EDM miniAOD format to a "simple flat ROOT TTree"

 Implementation:
    Based on https://twiki.cern.ch/twiki/bin/view/CMSPublic/WorkBookMiniAOD
    The base event is described by TTHTree, implemented in tth_tree.hh (autogenerated by tree_header.jl based on a specification)

    Tests for this module are in test/runtests.sh

    Helpful links:
        https://github.com/CJLST/ZZAnalysis/wiki/miniAOD-twiki
        https://twiki.cern.ch/twiki/bin/view/CMSPublic/WorkBookMiniAOD
*/
//
// Original Author:  Joosep Pata
//         Created:  Tue, 15 Jul 2014 10:06:28 GMT
//
//


// system include files
#include <memory>
#include <algorithm>
#include <string>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"

#include "DataFormats/PatCandidates/interface/Muon.h"
#include "DataFormats/PatCandidates/interface/Electron.h"
#include "DataFormats/PatCandidates/interface/Tau.h"
#include "DataFormats/PatCandidates/interface/Jet.h"

#include "DataFormats/VertexReco/interface/VertexFwd.h"
#include "DataFormats/VertexReco/interface/Vertex.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"

#include "FWCore/ServiceRegistry/interface/Service.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"

#include "DataFormats/PatCandidates/interface/PackedGenParticle.h"
#include "DataFormats/HepMCCandidate/interface/GenParticle.h"

#include "DataFormats/PatCandidates/interface/MET.h"
#include "DataFormats/PatCandidates/interface/PackedCandidate.h"

//for top tagger
//#include "DataFormats/JetReco/interface/CATopJetTagInfo.h"
#include "DataFormats/JetReco/interface/HTTTopJetTagInfo.h"

#include "SimDataFormats/PileupSummaryInfo/interface/PileupSummaryInfo.h"
#include "SimDataFormats/GeneratorProducts/interface/LHEEventProduct.h"

//#include "CommonTools/UtilAlgos/interface/PhysObjectMatcher.h"
//#include "CommonTools/UtilAlgos/interface/MatchByDRDPt.h"
//#include "CommonTools/UtilAlgos/interface/MatchLessByDPt.h"
//#include "CommonTools/UtilAlgos/interface/MCMatchSelector.h"
#include <EgammaAnalysis/ElectronTools/interface/ElectronEffectiveArea.h>

#include "FWCore/Common/interface/TriggerNames.h"
#include "DataFormats/Common/interface/TriggerResults.h"
#include "DataFormats/PatCandidates/interface/TriggerObjectStandAlone.h"
#include "DataFormats/PatCandidates/interface/PackedTriggerPrescales.h"

#include "TTH/TTHNtupleAnalyzer/interface/tth_tree.hh"

#include "TTH/TTHNtupleAnalyzer/interface/EventHypothesis.hh"

#include "TStopwatch.h"

#define CANDPRINT(x) " pt=" << x.pt() << " eta=" << x.eta() << " phi=" << x.phi() << " id=" << x.pdgId() << " st=" << x.status()
#define PCANDPRINT(x) " pt=" << x->pt() << " eta=" << x->eta() << " phi=" << x->phi() << " id=" << x->pdgId() << " st=" << x->status()
#define GENJET_DR 0.5
#define GENJET_REL_DP 0.5

#define GENLEPTON_DR 0.5
#define GENLEPTON_REL_DP 0.5

//how many good leptons to store in the good_lep array at most?
#define N_MAX_GOOD_LEPTONS 2

template <typename T, typename R>
std::vector<R> to_ptrvec(T coll) {
    std::vector<R> ret;
    for (auto e : coll) {
        assert(&e != NULL);
        ret.push_back((R)&e);
    }
    return ret;
}

template <typename T>
bool order_by_pt(T a, T b) {
    assert(a!=NULL && b!=NULL);
    return (a->pt() > b->pt());
};

const reco::GenParticle* find_dr_dp_id_match(const reco::Candidate& x, edm::Handle<edm::View<reco::GenParticle>> pruned) {
    std::vector<const reco::GenParticle*> matched;
    for (auto& p : *pruned) {
        const float dr = sqrt(reco::deltaR2(x.p4(), p.p4()));
        const float rel_dp = fabs(x.pt()-p.pt())/p.pt();
        //LogDebug("jets") << "dR=" << dr << " rel_dp=" << rel_dp;
        if (dr<GENLEPTON_DR && rel_dp<GENLEPTON_REL_DP && x.pdgId()==p.pdgId()) {
            matched.push_back(&p);
        }
    }
    LogDebug("find_dr_dp_id_match") << "dR < " << GENLEPTON_DR << " matched " << matched.size();

    //sort genparticles by dR(recojet, genparticle) ascending
    auto sortf = [&x](const reco::GenParticle* a, const reco::GenParticle* b) -> bool {
        return (reco::deltaR2(x.p4(), a->p4()) < reco::deltaR2(x.p4(), b->p4()));
    };

    std::sort(matched.begin(), matched.end(), sortf);
    //if we had at least one match, choose lowest dR
    if (matched.size()>0) {
        LogDebug("find_dr_dp_id_match") << "best match " << PCANDPRINT(matched[0]);
        return matched[0];
    } else {
        return (const reco::GenParticle*)NULL;
    }
}

typedef struct {
    float pt;
    float eta;
    float phi;
    int isL3;
    int isLF;
    //int index;
    void fill(float pt_ = -99, float eta_ = -99, float phi_  = -99,
              int isL3_ = -99, int isLF_  = -99 /*, int index_  = -99*/) {
        pt    = pt_ ;
        eta   = eta_;
        phi   = phi_;
        isL3  = isL3_;
        isLF  = isLF_;
        //index = index_;
    };
} LightTriggerObj ;



class TTHNtupleAnalyzer : public edm::EDAnalyzer {

public:
    explicit TTHNtupleAnalyzer(const edm::ParameterSet&);
    ~TTHNtupleAnalyzer();

    static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);


private:
    virtual void beginJob() override;
    virtual void analyze(const edm::Event&, const edm::EventSetup&) override;
    virtual void endJob() override;
    virtual void finalizeLoop();

    // collection of muons, electrons, taus, jets
    const edm::EDGetTokenT<pat::MuonCollection> muonToken_;
    const edm::EDGetTokenT<pat::ElectronCollection> electronToken_;
    const edm::EDGetTokenT<pat::TauCollection> tauToken_;
    const edm::EDGetTokenT<pat::JetCollection> jetToken_;

    // collection of top jets
    const edm::EDGetTokenT<edm::View<reco::BasicJet>> topJetToken_;
    const edm::EDGetTokenT<edm::View<reco::PFJet>> topJetSubjetToken_;
    const edm::EDGetTokenT<edm::View<reco::HTTTopJetTagInfo>> topJetInfoToken_;

    // collection of vertices
    const edm::EDGetTokenT<reco::VertexCollection> vertexToken_;

    // collection of gen particles
    const edm::EDGetTokenT<edm::View<reco::GenParticle> > prunedGenToken_;
    const edm::EDGetTokenT<edm::View<pat::PackedGenParticle> > packedGenToken_;

    // collection of fatjets and MET
    const edm::EDGetTokenT<pat::JetCollection> fatjetToken_;
    const edm::EDGetTokenT<pat::METCollection> metToken_;

    // LHE event product (may not be present!!)
    const edm::EDGetTokenT<LHEEventProduct> lheToken_;

    // the output tree
    TTHTree* tthtree;
    const edm::Service<TFileService> fs;

    // a watch for CPU monitoring
    TStopwatch* sw;

    //const ElectronEffectiveArea::ElectronEffectiveAreaType electron_eff_area_type = ElectronEffectiveArea::ElectronEffectiveAreaType::kEleGammaAndNeutralHadronIso03;
    //const ElectronEffectiveArea::ElectronEffectiveAreaType electron_eff_area_target = ElectronEffectiveArea::ElectronEffectiveAreaTarget::kEleEAData2012;

    // particle identifiers
    const std::vector<std::string> tauIdentifiers_;
    const std::vector<std::string> eleIdentifiers_;

    // trigger paths to be checked
    const std::vector<std::string> triggerIdentifiers_;
    const std::vector<std::string> triggerIdentifiersForMatching_;

    // trigger results
    const edm::EDGetTokenT<edm::TriggerResults> triggerBits_;
    const edm::EDGetTokenT<pat::TriggerObjectStandAloneCollection> triggerObjects_;
    const edm::EDGetTokenT<pat::PackedTriggerPrescales> triggerPrescales_;

    // parameters
    const bool    isMC_;
    const double jetPt_min_;
    const int    jetMult_min_;
    const double muPt_min_;
    const double elePt_min_;
    const double tauPt_min_;
};


TTHNtupleAnalyzer::TTHNtupleAnalyzer(const edm::ParameterSet& iConfig) :
    muonToken_(consumes<pat::MuonCollection>(iConfig.getParameter<edm::InputTag>("muons"))),
    electronToken_(consumes<pat::ElectronCollection>(iConfig.getParameter<edm::InputTag>("electrons"))),
    tauToken_(consumes<pat::TauCollection>(iConfig.getParameter<edm::InputTag>("taus"))),
    jetToken_(consumes<pat::JetCollection>(iConfig.getParameter<edm::InputTag>("jets"))),
    topJetToken_(consumes<edm::View<reco::BasicJet>>(iConfig.getParameter<edm::InputTag>("topjets"))),
    topJetSubjetToken_(consumes<edm::View<reco::PFJet>>(iConfig.getParameter<edm::InputTag>("topjetsubjets"))),
    topJetInfoToken_(consumes<edm::View<reco::HTTTopJetTagInfo>>(iConfig.getParameter<edm::InputTag>("topjetinfos"))),
    vertexToken_(consumes<reco::VertexCollection>(iConfig.getParameter<edm::InputTag>("vertices"))),
    prunedGenToken_(consumes<edm::View<reco::GenParticle> >(iConfig.getParameter<edm::InputTag>("pruned"))),
    packedGenToken_(consumes<edm::View<pat::PackedGenParticle> >(iConfig.getParameter<edm::InputTag>("packed"))),
    fatjetToken_(consumes<pat::JetCollection>(iConfig.getParameter<edm::InputTag>("fatjets"))),
    metToken_(consumes<pat::METCollection>(iConfig.getParameter<edm::InputTag>("mets"))),

    lheToken_( (iConfig.getParameter<edm::InputTag>("lhe")).label()!="" ?
               consumes<LHEEventProduct>( iConfig.getParameter<edm::InputTag>("lhe")) : edm::EDGetTokenT<LHEEventProduct>() ),

    tthtree(new TTHTree(fs->make<TTree>("events", "events"))),
    tauIdentifiers_(iConfig.getParameter<std::vector<std::string>>("tauIdentifiers")),
    eleIdentifiers_(iConfig.getParameter<std::vector<std::string>>("eleIdentifiers")),
    triggerIdentifiers_(iConfig.getParameter<std::vector<std::string>>("triggerIdentifiers")),
    triggerIdentifiersForMatching_(iConfig.getParameter<std::vector<std::string>>("triggerIdentifiersForMatching")),
    triggerBits_(consumes<edm::TriggerResults>(iConfig.getParameter<edm::InputTag>("bits"))),
    triggerObjects_(consumes<pat::TriggerObjectStandAloneCollection>(iConfig.getParameter<edm::InputTag>("objects"))),
    triggerPrescales_(consumes<pat::PackedTriggerPrescales>(iConfig.getParameter<edm::InputTag>("prescales"))),
    isMC_(iConfig.getParameter<bool>("isMC")),
    jetPt_min_  (iConfig.getUntrackedParameter<double>("jetPt_min", 5.)),
    jetMult_min_(iConfig.getUntrackedParameter<int>   ("jetMult_min", DEF_VAL_INT)),
    muPt_min_   (iConfig.getUntrackedParameter<double>("muPt_min",  5.)),
    elePt_min_  (iConfig.getUntrackedParameter<double>("elePt_min", 5.)),
    tauPt_min_  (iConfig.getUntrackedParameter<double>("tauPt_min", 5.))
{
    tthtree->make_branches();
    sw = new TStopwatch();
}


TTHNtupleAnalyzer::~TTHNtupleAnalyzer()
{
    delete sw;
}

void TTHNtupleAnalyzer::finalizeLoop() {
}

// ------------ method called for each event  ------------
void
TTHNtupleAnalyzer::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup)
{
    using namespace edm;

    sw->Start();
    tthtree->loop_initialize();

    tthtree->event__id   = (unsigned int)iEvent.id().event();
    tthtree->event__run  = (unsigned int)iEvent.id().run();
    tthtree->event__lumi = (unsigned int)iEvent.id().luminosityBlock();

    //Primary vertices
    edm::Handle<reco::VertexCollection> vertices;
    iEvent.getByToken(vertexToken_, vertices);
    if (vertices->empty()) {
        edm::LogError("loop") << "no vertices found";
        finalizeLoop();
        return;
    }
    const reco::Vertex &PV = vertices->front();
    tthtree->n__pv = vertices->size();

    if (isMC_) {
    Handle<edm::View<reco::GenParticle> > pruned;
    
    //Pileup and genparticles
        Handle<std::vector<PileupSummaryInfo>> PupInfo;
        iEvent.getByLabel(edm::InputTag("addPileupInfo"), PupInfo);
        std::vector<PileupSummaryInfo>::const_iterator PVI;
        tthtree->n__pvi = PupInfo->size();
        int n_pu = 0;
        for (PVI = PupInfo->begin(); PVI != PupInfo->end(); ++PVI)
        {
            const int BX = PVI->getBunchCrossing();
            LogDebug("PVI") << n_pu << " BX=" << BX;
            tthtree->pvi__n0[n_pu] = PVI->getPU_NumInteractions();
            tthtree->pvi__bx[n_pu] = BX;
            if (BX == 0)
            {
                tthtree->pvi__ntrue[n_pu] = PVI->getTrueNumInteractions();
            }
            n_pu += 1;
        }
    }

    edm::Handle<edm::TriggerResults> triggerBits;
    edm::Handle<pat::TriggerObjectStandAloneCollection> triggerObjects;
    edm::Handle<pat::PackedTriggerPrescales> triggerPrescales;

    iEvent.getByToken(triggerBits_,      triggerBits);
    iEvent.getByToken(triggerObjects_,   triggerObjects);
    iEvent.getByToken(triggerPrescales_, triggerPrescales);


    const edm::TriggerNames &names = iEvent.triggerNames(*triggerBits);
    //std::cout << "\n === TRIGGER PATHS === " << std::endl;

    //trigger identifiers
    int n__tr = 0;
    
    Handle<edm::View<reco::GenParticle> > pruned;
    if (isMC_) {
        iEvent.getByToken(prunedGenToken_,pruned);
    }

    for (unsigned int j = 0; j < triggerIdentifiers_.size(); ++j) {

        string idName = triggerIdentifiers_[j];
        string idNameUnstarred = idName;
        bool isStarred = (idName.find("*")!=string::npos);
        if( isStarred ) idNameUnstarred.erase( idName.find("*"), 1 );

        for (unsigned int i = 0, n = triggerBits->size(); i < n; ++i) {

            if( (isStarred  && names.triggerName(i).find(idNameUnstarred)!=string::npos ) ||
                    (!isStarred && names.triggerName(i)==idName)
              ) {
                tthtree->trigger__bits    [n__tr] = triggerBits->accept(i);
                tthtree->trigger__prescale[n__tr] = triggerPrescales->getPrescaleForIndex(i);
            }
            //std::cout << "Trigger " << names.triggerName(i) <<
            //", prescale " << triggerPrescales->getPrescaleForIndex(i) <<
            //": " << (triggerBits->accept(i) ? "PASS" : "fail (or not run)") << std::endl;
            //std::cout <<  "'" << names.triggerName(i) << "'," << std::endl;
        }
        n__tr++;
    }
    tthtree->n__tr = n__tr;

    if(  int(triggerIdentifiers_.size())>=T_MAX ) {
        edm::LogError("T_MAX") << "Exceeded vector T_MAX with n__tr: " << n__tr << ">=> " << T_MAX;
        throw std::exception();
    }

    /////////////////////////////////////////////
    //std::cout << "\n === TRIGGER OBJECTS === " << std::endl;
    vector< LightTriggerObj > muTriggerObj;
    vector< LightTriggerObj > eleTriggerObj;

    //FIXME 09.10.14: this loop currently crashes
    int countObj = 0;
    for (pat::TriggerObjectStandAlone obj : *triggerObjects) { // note: not "const &" since we want to call unpackPathNames
        LogDebug("triggers") << "triggerObject loop";

        //unpackPathNames crashes
        obj.unpackPathNames(names);
        LogDebug("triggers") << "unpacked names";
        unsigned filterSize = obj.filterIds().size();
        LogDebug("triggers") << "filterSize" << filterSize;
        if( filterSize!=1 ) continue;

        LightTriggerObj lightObj;

        // electron/muons HLTs
        if( obj.filterIds()[0] == 82 || obj.filterIds()[0] == 83 ) {

            bool isL3 = false;
            bool isLF = false;

            // all path names associated to this obj
            std::vector<std::string> pathNamesAll = obj.pathNames(false);
            LogDebug("triggers") << "pathNamesAll" << pathNamesAll.size();

            // loop over them
            for (unsigned h = 0, n = pathNamesAll.size(); h < n; ++h) {

                // loop over the trigger bits for which we require a match
                for (unsigned int j = 0; j < triggerIdentifiersForMatching_.size(); ++j) {
                    // check whether we have starred names
                    const string idName          =  triggerIdentifiersForMatching_[j];
                    LogDebug("triggers") << "identifier for matcing " << idName;
                    string idNameUnstarred = idName;
                    bool isStarred         = idName.find("*")!=string::npos;
                    if( isStarred ) idNameUnstarred.erase( idName.find("*"), 1 );

                    // check whether this path matches
                    if( ((isStarred  && pathNamesAll[h].find(idNameUnstarred)!=string::npos ) ||
                            (!isStarred && pathNamesAll[h]==idName)) &&
                            (( obj.filterIds()[0] == 82 && idNameUnstarred.find("Ele")!=string::npos ) ||
                             ( obj.filterIds()[0] == 83 && idNameUnstarred.find("Mu")!=string::npos && obj.collection().find("L3")!=string::npos ))
                      ) {
                        bool isL3tmp   = obj.hasPathName( pathNamesAll[h], false, true );
                        bool isLFtmp   = obj.hasPathName( pathNamesAll[h], true, false );
                        //cout << h << "th path for Obj "<< countObj << " with " <<  obj.filterIds()[0] << " with pt=" << obj.pt() << "  matches to [" << j << "]" << endl;
                        isL3 = isL3 || isL3tmp;
                        isLF = isLF || (isLFtmp && isL3tmp);
                    }

                }
            }

            if(isL3) {
                lightObj.fill( obj.pt(), obj.eta(), obj.phi(), isL3, isLF );
                if(obj.filterIds()[0] == 82)
                    eleTriggerObj.push_back( lightObj );
                if(obj.filterIds()[0] == 83)
                    muTriggerObj.push_back ( lightObj );
            }

        } // is Ele or muon
        countObj++;
    }

    /*
    for(unsigned int m = 0 ; m < eleTriggerObj.size(); m++){
      cout << m << "th ele: pt=" << eleTriggerObj[m].pt << ", eta=" <<  eleTriggerObj[m].eta
     << ", PASS trigger ["  << "]: " <<  eleTriggerObj[m].isL3 <<  eleTriggerObj[m].isLF <<  endl;
    }
    for(unsigned int m = 0 ; m < muTriggerObj.size(); m++){
      cout << m << "th mu: pt=" << muTriggerObj[m].pt << ", eta=" <<  muTriggerObj[m].eta
     << ", PASS trigger [" << "]: " <<  muTriggerObj[m].isL3 <<  muTriggerObj[m].isLF <<  endl;
    }
    */
    //////////////////////////////////////////////////////////

    edm::Handle<pat::MuonCollection> muons;
    iEvent.getByToken(muonToken_, muons);

    // lepton counters
    int n__lep = 0;
    int n__mu = 0;
    int n__ele = 0;
    int n__tau = 0;

    //collection to keep track of lepton pointers in the same order as in the tthtree->lep__* arrays
    vector<const reco::Candidate*> leptons;

    // jet counter
    int n__jet = 0;

    for (const pat::Muon &x : *muons) {
        LogDebug("muons") << "n__mu=" << n__mu <<
                          " pt=" << x.pt() <<
                          " dz(PV)=" << x.muonBestTrack()->dz(PV.position()) <<
                          " lID=" << x.isLooseMuon() <<
                          " tID=" << x.isTightMuon(PV);

        if( x.pt()<muPt_min_ ) {
            LogDebug("muons") << "n__mu=" << n__mu << " fails pt cut" << endl;
            continue;
        }
        leptons.push_back((const reco::Candidate*)&x);

        float minDist = 999.;
        float minDpT  = 999.;
        for(unsigned int m = 0 ; m < muTriggerObj.size(); m++) {
            LightTriggerObj obj = muTriggerObj[m];
            float dist = sqrt( (obj.eta-x.eta())*(obj.eta-x.eta()) + (obj.phi-x.phi())*(obj.phi-x.phi()) );
            float dpT  = fabs( obj.pt - x.pt() )/x.pt();
            if( dist<minDist && dist<0.50 && dpT<minDpT && dpT<0.50 ) {
                tthtree->trig_lep__pt [n__lep] = obj.pt;
                tthtree->trig_lep__eta[n__lep] = obj.eta;
                tthtree->trig_lep__phi[n__lep] = obj.phi;
                tthtree->trig_lep__pass[n__lep]= obj.isLF + 1;
                minDist = dist;
                minDpT  = dpT;
            }
        }
        if( minDist>998. ) {
            tthtree->trig_lep__pass[n__lep] = 0;
        }

        tthtree->lep__eta[n__lep] = x.eta();
        tthtree->lep__pt[n__lep] = x.pt();
        tthtree->lep__phi[n__lep] = x.phi();
        tthtree->lep__mass[n__lep] = x.mass();
        tthtree->lep__id[n__lep] = x.pdgId();
        tthtree->lep__type[n__lep] = abs(x.pdgId());
        tthtree->lep__charge[n__lep] = x.charge();

        tthtree->lep__is_tight[n__lep] = is_tight_muon(x, PV);
        tthtree->lep__is_loose[n__lep] = is_loose_muon(x);

        tthtree->lep__ch_iso[n__lep] = x.chargedHadronIso();
        tthtree->lep__puch_iso[n__lep] = x.puChargedHadronIso();
        tthtree->lep__ec_iso[n__lep] = x.ecalIso();
        tthtree->lep__hc_iso[n__lep] = x.hcalIso();
        tthtree->lep__p_iso[n__lep] = x.particleIso();
        tthtree->lep__ph_iso[n__lep] = x.photonIso();

        //manual DBC iso
        //const auto& pfiso = x.pfIsolationR04();
        //tthtree->lep__rel_iso[n__lep] = (pfiso.sumChargedHadronPt + std::max(0.0, pfiso.sumNeutralHadronEt + pfiso.sumPhotonEt - 0.5 * pfiso.sumPUPt))/x.pt();

        //automatic delta-beta relative isolation
        tthtree->lep__rel_iso[n__lep] = dbc_rel_iso(x);

        if (x.muonBestTrack().isNonnull()) {
            tthtree->lep__dxy[n__lep] = x.muonBestTrack()->dxy(PV.position());
            tthtree->lep__dz[n__lep] = x.muonBestTrack()->dz(PV.position());
        } else {
            edm::LogWarning("muon") << "gsfTrack is 0 for n__mu=" << n__mu;
        }
        if (isMC_) {
            const reco::GenParticle* gp = x.genParticle();
            if (gp == NULL) {
                LogDebug("muon") << "n__lep=" << n__lep << " does not have genParticle(), doing dR/dP matching";
                gp = find_dr_dp_id_match(x, pruned);
            }
            if (x.genParticle() != NULL) {
                tthtree->gen_lep__eta[n__lep] = gp->eta();
                tthtree->gen_lep__pt[n__lep] = gp->pt();
                tthtree->gen_lep__phi[n__lep] = gp->phi();
                tthtree->gen_lep__mass[n__lep] = gp->mass();
                tthtree->gen_lep__id[n__lep] = gp->pdgId();
                tthtree->gen_lep__status[n__lep] = gp->status();
            } else {
                LogDebug("muons") << "genParticle()==0 for muon n__mu=" << n__mu;
            }
        }
        n__mu += 1;
        n__lep += 1;
    } //muons


    //Electrons
    edm::Handle<pat::ElectronCollection> electrons;
    iEvent.getByToken(electronToken_, electrons);
    for (const pat::Electron &x : *electrons) {
        LogDebug("electrons") << "n__ele=" << n__ele <<
                              " pt=" << x.pt();
        if( x.pt()<elePt_min_ ) {
            LogDebug("electrons") << "n__ele=" << n__ele << " fails pt cut" << endl;
            continue;
        }
        
        float minDist = 999.;
        float minDpT  = 999.;
        for(unsigned int m = 0 ; m < eleTriggerObj.size(); m++) {
            LightTriggerObj obj = eleTriggerObj[m];
            float dist = sqrt( (obj.eta-x.eta())*(obj.eta-x.eta()) + (obj.phi-x.phi())*(obj.phi-x.phi()) );
            float dpT  = fabs( obj.pt - x.pt() )/x.pt();
            if( dist<minDist && dist<0.50 && dpT<minDpT && dpT<0.50 ) {
                tthtree->trig_lep__pt [n__lep] = obj.pt;
                tthtree->trig_lep__eta[n__lep] = obj.eta;
                tthtree->trig_lep__phi[n__lep] = obj.phi;
                tthtree->trig_lep__pass[n__lep]= obj.isLF + 1;
                minDist = dist;
                minDpT  = dpT;
            }
        }
        if( minDist>998. ) {
            tthtree->trig_lep__pass[n__lep] = 0;
        }
        leptons.push_back((const reco::Candidate*)&x);

        tthtree->lep__eta[n__lep] = x.eta();
        tthtree->lep__pt[n__lep] = x.pt();
        tthtree->lep__phi[n__lep] = x.phi();
        tthtree->lep__mass[n__lep] = x.mass();
        tthtree->lep__id[n__lep] = x.pdgId();
        tthtree->lep__charge[n__lep] = x.charge();

        tthtree->lep__ch_iso[n__lep] = x.chargedHadronIso();
        tthtree->lep__puch_iso[n__lep] = x.puChargedHadronIso();
        tthtree->lep__ec_iso[n__lep] = x.ecalIso();
        tthtree->lep__hc_iso[n__lep] = x.hcalIso();
        tthtree->lep__p_iso[n__lep] = x.particleIso();
        tthtree->lep__ph_iso[n__lep] = x.photonIso();

        //manual rho-corrected, probably deprecated
        //const double eff_area = ElectronEffectiveArea::GetElectronEffectiveArea(
        //    electron_eff_area_type,
        //    x.eta(),
        //    electron_eff_area_target
        //);
        //isocorr = PFChargedIso (PFNoPU) + max(PFIso(γ+NH) - rho * Aeff(γ+NH), 0.)
        //float rc_iso = (lepton.chargedHadronIso() + std::max(0., lepton.neutralHadronIso() + lepton.photonIso() - ea*(*rho)))/lepton.userFloat("ptCorr");
        tthtree->lep__rel_iso[n__lep] = dbc_rel_iso(x);

        tthtree->lep__is_tight[n__lep] = is_tight_electron(x, PV);
        tthtree->lep__is_loose[n__lep] = is_loose_electron(x, PV);

        unsigned int ele_id_idx = 0;
        tthtree->lep__id_bitmask[n__lep] = 0;
        for (const auto& ele_id : eleIdentifiers_) {
            LogDebug("ele") << " n__lep=" << n__lep << " ID(" << ele_id << ")=" << x.electronID(ele_id);
            if (x.electronID(ele_id)) {
                //passes, flip bit with index tau_id_idx to ON
                tthtree->lep__id_bitmask[n__lep] = tthtree->lep__id_bitmask[n__lep] | (1 << ele_id_idx);
            } else {
                //fails, flip bit with index tau_id_idx to OFF
                tthtree->lep__id_bitmask[n__lep] = tthtree->lep__id_bitmask[n__lep] & ~(1 << ele_id_idx);
            }
            ele_id_idx += 1;
            if (ele_id_idx>= 32) {
                edm::LogWarning("ele") << "More electron ID-s specified than can fit in bitmask, truncating after " << ele_id;
                break;
            }
        }

        if (x.gsfTrack().isNonnull()) {
            tthtree->lep__dxy[n__lep] = x.gsfTrack()->dxy(PV.position());
            tthtree->lep__dz[n__lep] = x.gsfTrack()->dz(PV.position());
        } else {
            edm::LogWarning("electron") << "gsfTrack is 0 for n__ele=" << n__ele;
        }
        if (isMC_) {
            const reco::GenParticle* gp = x.genParticle();
            if (gp == NULL) {
                LogDebug("electron") << "n__lep=" << n__lep << " does not have genParticle(), doing dR/dP matching";
                gp = find_dr_dp_id_match(x, pruned);
            }
            if (gp != NULL) {
                tthtree->gen_lep__eta[n__lep] = gp->eta();
                tthtree->gen_lep__pt[n__lep] = gp->pt();
                tthtree->gen_lep__phi[n__lep] = gp->phi();
                tthtree->gen_lep__mass[n__lep] = gp->mass();
                tthtree->gen_lep__id[n__lep] = gp->pdgId();
                tthtree->gen_lep__status[n__lep] = gp->status();
            } else {
                LogDebug("electron") << "genParticle()==0 for electron n__ele=" << n__ele;
            }
        }
        n__ele += 1;
        n__lep += 1;
    } // electrons

    edm::Handle<pat::TauCollection> taus;
    iEvent.getByToken(tauToken_, taus);
    for (const pat::Tau &x : *taus) {
        LogDebug("taus") << "n__tau=" << n__tau <<
            " pt=" << x.pt();
        
        if( x.pt()<tauPt_min_ ) {
            LogDebug("taus") << "n__tau=" << n__tau << " fails pt cut" << endl;
            continue;
        }

        leptons.push_back((const reco::Candidate*)&x);

        tthtree->lep__eta[n__lep] = x.eta();
        tthtree->lep__pt[n__lep] = x.pt();
        tthtree->lep__phi[n__lep] = x.phi();
        tthtree->lep__mass[n__lep] = x.mass();
        tthtree->lep__id[n__lep] = x.pdgId();
        tthtree->lep__charge[n__lep] = x.charge();

        tthtree->lep__ch_iso[n__lep] = x.chargedHadronIso();
        tthtree->lep__puch_iso[n__lep] = x.puChargedHadronIso();
        tthtree->lep__ec_iso[n__lep] = x.ecalIso();
        tthtree->lep__hc_iso[n__lep] = x.hcalIso();
        tthtree->lep__p_iso[n__lep] = x.particleIso();
        tthtree->lep__ph_iso[n__lep] = x.photonIso();

        //Bit-shift specified tau id-s into the id_bitmask
        //Order is specified in the python config
        //http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c
        unsigned int tau_id_idx = 0;
        tthtree->lep__id_bitmask[n__lep] = 0;
        for (const auto& tau_id : tauIdentifiers_) {
            if (x.tauID(tau_id)) {
                //passes, flip bit with index tau_id_idx to ON
                tthtree->lep__id_bitmask[n__lep] = tthtree->lep__id_bitmask[n__lep] | (1 << tau_id_idx);
            } else {
                //fails, flip bit with index tau_id_idx to OFF
                tthtree->lep__id_bitmask[n__lep] = tthtree->lep__id_bitmask[n__lep] & ~(1 << tau_id_idx);
            }
            tau_id_idx += 1;
            if (tau_id_idx>= 32) {
                edm::LogWarning("tau") << "More tau ID-s specified than can fit in bitmask, truncating after " << tau_id;
                break;
            }
        }


        if (x.leadTrack().isNonnull()) {
            tthtree->lep__dxy[n__lep] = x.leadTrack()->dxy(PV.position());
            tthtree->lep__dz[n__lep] = x.leadTrack()->dz(PV.position());
        } else {
            LogDebug("tau") << "leadTrack is 0 for n__tau=" << n__tau;
        }

        const reco::GenParticle* gp = x.genParticle();
        if (isMC_) {
            if (gp == NULL) {
                LogDebug("tau") << "n__lep=" << n__lep << " does not have genParticle(), doing dR/dP matching";
                gp = find_dr_dp_id_match(x, pruned);
            }

            if (gp != NULL) {
                tthtree->gen_lep__eta[n__lep] = gp->eta();
                tthtree->gen_lep__pt[n__lep] = gp->pt();
                tthtree->gen_lep__phi[n__lep] = gp->phi();
                tthtree->gen_lep__mass[n__lep] = gp->mass();
                tthtree->gen_lep__id[n__lep] = gp->pdgId();
                tthtree->gen_lep__status[n__lep] = gp->status();
            } else {
                LogDebug("taus") << "genParticle()==0 for tau n__tau=" << n__tau;
            }
        }
        n__tau += 1;
        n__lep += 1;
    } // taus
     

    edm::Handle<pat::JetCollection> jets;
    iEvent.getByToken(jetToken_, jets);

    //sort jets by pt
    //auto jetps = to_ptrvec<const std::vector<pat::Jet>&, const pat::Jet*>(*jets);
    //std::sort(jetps.begin(), jetps.end(), order_by_pt<const pat::Jet*>);

    for (auto x : *jets) {
        //assert(_x != NULL);
        LogDebug("jets") << "n__jet=" << n__jet << CANDPRINT(x);

        // jet pt cut
        if( x.pt()<jetPt_min_ ) {
            LogDebug("jets") << "n__jet=" << n__jet << " fails pt cut" << endl;
            continue;
        }

        // jet ID
        if( !jetID( x ) ) {
            LogDebug("jets") << "n__jet=" << n__jet << " fails ID cut" << endl;
            continue;
        }

        tthtree->jet__eta           [n__jet] = x.eta();
        tthtree->jet__pt            [n__jet] = x.pt();
        tthtree->jet__phi           [n__jet] = x.phi();
        tthtree->jet__mass          [n__jet] = x.mass();
        tthtree->jet__energy        [n__jet] = x.energy();
        tthtree->jet__bd_csv        [n__jet] = x.bDiscriminator("combinedSecondaryVertexBJetTags");
        tthtree->jet__id            [n__jet] = x.partonFlavour();

        tthtree->jet__jetId         [n__jet]  = int(jetID( x ));
        tthtree->jet__pileupJetId   [n__jet]  = x.userFloat("pileupJetId:fullDiscriminant");
        tthtree->jet__vtxMass       [n__jet]  = x.userFloat("vtxMass") ;
        tthtree->jet__vtxNtracks    [n__jet]  = x.userFloat("vtxNtracks")  ;
        tthtree->jet__vtx3DVal      [n__jet]  = x.userFloat("vtx3DVal")  ;
        tthtree->jet__vtx3DSig      [n__jet]  = x.userFloat("vtx3DSig")  ;

        tthtree->jet__nh_e          [n__jet] = x.neutralHadronEnergy();
        tthtree->jet__ne_e          [n__jet] = x.neutralEmEnergy();
        tthtree->jet__ch_e          [n__jet] = x.chargedHadronEnergy();
        tthtree->jet__ce_e          [n__jet] = x.chargedEmEnergy();
        tthtree->jet__mu_e          [n__jet] = x.muonEnergy();
        tthtree->jet__el_e          [n__jet] = x.electronEnergy();
        tthtree->jet__ph_e          [n__jet] = x.photonEnergy();

        //unsigned int constituent_idx = 0;
        //for (const auto& constituent : x.getJetConstituents()) {
        //    if (n__jet >= M_MAX || constituent_idx >= M_MAX) {
        //        LogDebug("jet") << "jet constituent maximum count reached: n__jet=" << n__jet << " n_constituent=" << constituent_idx << " max=" << M_MAX;
        //        break;
        //    }
        //    if (constituent.isNull()) {
        //        edm::LogWarning("jet") << "jet constituent is null: n__jet=" << n__jet << " n_constituent=" << constituent_idx;
        //        break;
        //    }
        //    tthtree->jet__c_pt[n__jet][constituent_idx] = constituent->pt();
        //    constituent_idx += 1;
        //}

        if (isMC_) {
            //generated parton
            const reco::GenParticle* gp = x.genParticle();
            if (gp == NULL) {
                LogDebug("jets") << "n__jet=" << n__jet << " does not have genParticle(), doing dR/dP matching";
                std::vector<const reco::GenParticle*> matched;
                for (auto& p : *pruned) {
                    const float dr = sqrt(reco::deltaR2(x.p4(), p.p4()));
                    const float rel_dp = fabs(x.pt()-p.pt())/p.pt();
                    //LogDebug("jets") << "dR=" << dr << " rel_dp=" << rel_dp;
                    if (dr<GENJET_DR && rel_dp<GENJET_REL_DP) {
                        matched.push_back(&p);
                    }
                }
                LogDebug("jets") << "dR < " << GENJET_DR << " matched " << matched.size();

                //sort genparticles by dR(recojet, genparticle) ascending
                auto sortf = [&x](const reco::GenParticle* a, const reco::GenParticle* b) -> bool {
                    return (reco::deltaR2(x.p4(), a->p4()) < reco::deltaR2(x.p4(), b->p4()));
                };

                std::sort(matched.begin(), matched.end(), sortf);
                //if we had at least one match, choose lowest dR
                if (matched.size()>0) {
                    gp = matched[0];
                    LogDebug("jets") << "best match " << PCANDPRINT(gp);
                }
            }

            if (gp != NULL) {
                tthtree->gen_jet_parton__eta[n__jet] = gp->eta();
                tthtree->gen_jet_parton__pt[n__jet] = gp->pt();
                tthtree->gen_jet_parton__phi[n__jet] = gp->phi();
                tthtree->gen_jet_parton__mass[n__jet] = gp->mass();
                tthtree->gen_jet_parton__id[n__jet] = gp->pdgId();
                tthtree->gen_jet_parton__status[n__jet] = gp->status();

                //we can also loop over the gen particle mothers
                for (auto _m : gp->motherRefVector()) {
                    if (_m.isNull()) {
                        continue;
                    }
                    auto& m = *_m;
                    LogDebug("jets") << "jet " << n__jet << " genParticle mother " << CANDPRINT(m);
                }
            } else {
                LogDebug("jets") << "jet " << n__jet << " genParticle==0";
            }

            //generator-level jet
            const reco::GenJet* gj = x.genJet();
            if (gj != NULL) {
                tthtree->gen_jet__eta[n__jet] = gj->eta();
                tthtree->gen_jet__pt[n__jet] = gj->pt();
                tthtree->gen_jet__phi[n__jet] = gj->phi();
                tthtree->gen_jet__mass[n__jet] = gj->mass();

                //FIXME: this id assignment does not seem to be correct. See issue #5 https://github.com/jpata/tthbb13/issues/5
                tthtree->gen_jet__id[n__jet] = gj->pdgId();

                tthtree->gen_jet__status[n__jet] = gj->status();

                ////Get generator level constituents
                ////FIXME: do we want to save the constituents or just perform some maths on it?
                //unsigned int i = 0;
                //for (auto cn : gj->getGenConstituents()) {
                //    if (i >= M_MAX || n__jet >= M_MAX) {
                //        LogDebug("jets") << "constituent " << i << " loop iteration exceeded M_MAX=" << M_MAX;
                //        break;
                //    }
                //    if (cn != NULL) {
                //        LogDebug("jets") << "constituent " << i << " is null";
                //        continue;
                //    } else {
                //        LogDebug("jets") << "constituent " << i << " is not null";
                //    }
                //    LogDebug("jets") << "constituent " << i << cn->pt();
                //    LogDebug("jets") << "constituent " << i << " " << PCANDPRINT(cn);
                //    LogDebug("jets") << "constituent " << i << " end of loop";
                //    i += 1;
                //}


            } else {
                LogDebug("jet") << "jet " << n__jet << " did not have genJet";
            }
        } // isMC
        n__jet += 1;
    } //jet loop

    //do initial hypothesis assignment
    vector<const pat::Muon*> good_muons_sl = TTH::find_good_muons(*muons, PV, TTH::DecayMode::semileptonic);
    vector<const pat::Electron*> good_electrons_sl = TTH::find_good_electrons(*electrons, PV, TTH::DecayMode::semileptonic);
    vector<const pat::Tau*> good_taus_sl = TTH::find_good_taus(*taus, TTH::DecayMode::semileptonic);
    vector<const pat::Jet*> good_jets_sl = TTH::find_good_jets(*jets, TTH::DecayMode::semileptonic);
    
    vector<const pat::Muon*> good_muons_dl = TTH::find_good_muons(*muons, PV, TTH::DecayMode::dileptonic);
    vector<const pat::Electron*> good_electrons_dl = TTH::find_good_electrons(*electrons, PV, TTH::DecayMode::dileptonic);
    vector<const pat::Tau*> good_taus_dl = TTH::find_good_taus(*taus, TTH::DecayMode::dileptonic);
    vector<const pat::Jet*> good_jets_dl = TTH::find_good_jets(*jets, TTH::DecayMode::dileptonic);
    
    TTH::EventDescription desc_sl(good_muons_sl, good_electrons_sl, good_taus_sl, good_jets_sl);
    TTH::EventDescription desc_dl(good_muons_dl, good_electrons_dl, good_taus_dl, good_jets_dl);
    LogDebug("hypo") << "SL hypo mu " << good_muons_sl.size() << " ele " << good_electrons_sl.size() << " tau " << good_taus_sl.size() << " jet " << good_jets_sl.size();   
    LogDebug("hypo") << "DL hypo mu " << good_muons_dl.size() << " ele " << good_electrons_dl.size() << " tau " << good_taus_dl.size() << " jet " << good_jets_sl.size();   
    
    TTH::EventHypothesis hypo = assign_event_hypothesis(desc_sl, desc_dl);
    LogDebug("hypo") << "chosen hypo " << hypo;
    tthtree->hypo1 = (int)hypo;

    //Dilepton hypothesis, concatenate lepton arrays, sort by pt and put into TTree array
    vector<const reco::Candidate*> good_leptons;
    if (hypo == TTH::EventHypothesis::ee ||
        hypo == TTH::EventHypothesis::mumu ||
        hypo == TTH::EventHypothesis::tautau ||
        hypo == TTH::EventHypothesis::emu ||
        hypo == TTH::EventHypothesis::taue ||
        hypo == TTH::EventHypothesis::taumu
    ) {
        for (auto* x : good_muons_dl) {
            good_leptons.push_back((const reco::Candidate*)x); 
        }
        for (auto* x : good_electrons_dl) {
            good_leptons.push_back((const reco::Candidate*)x); 
        }
        for (auto* x : good_taus_dl) {
            good_leptons.push_back((const reco::Candidate*)x); 
        }

        //must be 2, otherwise there was a bug in the hypothesis assignment
        assert(good_leptons.size()==2);
    }
    
    if (hypo == TTH::EventHypothesis::en ||
        hypo == TTH::EventHypothesis::mun ||
        hypo == TTH::EventHypothesis::taun
    ) {
        for (auto* x : good_muons_sl) {
            good_leptons.push_back((const reco::Candidate*)x); 
        }
        for (auto* x : good_electrons_sl) {
            good_leptons.push_back((const reco::Candidate*)x); 
        }
        for (auto* x : good_taus_sl) {
            good_leptons.push_back((const reco::Candidate*)x); 
        }

        //must be 1, otherwise there was a bug in the hypothesis assignment
        assert(good_leptons.size()==1);
       
    }
    //sort by pt descending
    sort(good_leptons.begin(), good_leptons.end(), order_by_pt<const reco::Candidate*>);

    for (unsigned int i=0; i<good_leptons.size(); i++) {
        tthtree->sig_lep__pt[i] = good_leptons[i]->pt();
        tthtree->sig_lep__eta[i] = good_leptons[i]->eta();
        tthtree->sig_lep__phi[i] = good_leptons[i]->phi();
        tthtree->sig_lep__mass[i] = good_leptons[i]->mass();
	// FIXME initiaize more vars

        //get index into main lepton array
        tthtree->sig_lep__idx[i] = find(leptons.begin(), leptons.end(), good_leptons[i]) - leptons.begin();
    }
    tthtree->n__sig_lep = good_leptons.size();

    if( jetMult_min_>0 && n__jet<jetMult_min_ ) {
        LogDebug("Event Cuts") << n__jet << " jets: skip this event" << endl;
        return;
    }

    //Top tagger jets
    edm::Handle<edm::View<reco::BasicJet>> top_jets;
    iEvent.getByToken(topJetToken_, top_jets);

    edm::Handle<edm::View<reco::HTTTopJetTagInfo>> top_jet_infos;
    iEvent.getByToken(topJetInfoToken_, top_jet_infos);

    assert(top_jets->size()==top_jet_infos->size());

    //Top jets and subjets are associated by indices
    //See /cvmfs/cms.cern.ch/slc6_amd64_gcc481/cms/cmssw/CMSSW_7_0_9/src/RecoJets/JetProducers/plugins/CompoundJetProducer.cc
    //about the association
    int n_top_jet_subjet = 0;

    for (unsigned int n_top_jet=0; n_top_jet<top_jets->size(); n_top_jet++) {
        const reco::BasicJet& x = top_jets->at(n_top_jet);
        const reco::HTTTopJetTagInfo& jet_info = top_jet_infos->at(n_top_jet);
        //assert(_x != NULL);
        //const pat::Jet& x = *_x;
        LogDebug("top jets") << "n_top_jet=" << n_top_jet << CANDPRINT(x);
        tthtree->jet_toptagger__eta[n_top_jet] = x.eta();
        tthtree->jet_toptagger__pt[n_top_jet] = x.pt();
        tthtree->jet_toptagger__phi[n_top_jet] = x.phi();
        tthtree->jet_toptagger__mass[n_top_jet] = x.mass();
        tthtree->jet_toptagger__energy[n_top_jet] = x.energy();
        tthtree->jet_toptagger__topMass[n_top_jet] = jet_info.properties().topMass;
        tthtree->jet_toptagger__unfilteredMass[n_top_jet] = jet_info.properties().unfilteredMass;
        tthtree->jet_toptagger__prunedMass[n_top_jet] = jet_info.properties().prunedMass;
        tthtree->jet_toptagger__fW[n_top_jet] = jet_info.properties().fW;
        tthtree->jet_toptagger__massRatioPassed[n_top_jet] = jet_info.properties().massRatioPassed;
        tthtree->jet_toptagger__isMultiR[n_top_jet] = (int)jet_info.properties().isMultiR;
        tthtree->jet_toptagger__Rmin[n_top_jet] = jet_info.properties().Rmin;
        tthtree->jet_toptagger__RminExpected[n_top_jet] = jet_info.properties().RminExpected;
        //FIXME: nSubJets no longer in new top jet properties
        //tthtree->jet_toptagger__n_sj[n_top_jet] = jet_info.properties().nSubJets;
        tthtree->jet_toptagger__n_sj[n_top_jet] = 3;

        bool first = true;
        for (auto& constituent : x.getJetConstituents()) {
            if (constituent.isNull()) {
                edm::LogWarning("top jets") << "n_top_jet=" << n_top_jet << " constituent is not valid";
                break;
            }
            if (first) {
                tthtree->jet_toptagger__child_idx[n_top_jet] = n_top_jet_subjet;
            }
            tthtree->jet_toptagger_sj__eta[n_top_jet_subjet] = constituent->eta();
            tthtree->jet_toptagger_sj__pt[n_top_jet_subjet] = constituent->pt();
            tthtree->jet_toptagger_sj__phi[n_top_jet_subjet] = constituent->phi();
            tthtree->jet_toptagger_sj__mass[n_top_jet_subjet] = constituent->mass();
            tthtree->jet_toptagger_sj__energy[n_top_jet_subjet] = constituent->energy();
            tthtree->jet_toptagger_sj__parent_idx[n_top_jet_subjet] = n_top_jet;
            n_top_jet_subjet += 1;

            first = false;
        }
    }
    tthtree->n__jet_toptagger = top_jets->size();
    tthtree->n__jet_toptagger_sj = n_top_jet_subjet;

    if (n__lep>=N_MAX) {
        edm::LogError("N_MAX") << "Exceeded vector N_MAX with n__lep: " << n__lep << ">=> " << N_MAX;
        throw std::exception();
    }

    if (n__jet>=N_MAX) {
        edm::LogError("N_MAX") << "Exceeded vector N_MAX with n__jet: " << n__jet << ">=> " << N_MAX;
        throw std::exception();
    }


    //edm::Handle<pat::JetCollection> fatjets;
    //iEvent.getByToken(fatjetToken_, fatjets);
    //for (const pat::Jet &j : *fatjets) {
    //}

    edm::Handle<pat::METCollection> mets;
    iEvent.getByToken(metToken_, mets);
    const pat::MET &met = mets->front();
    tthtree->met__pt = met.pt();
    tthtree->met__phi = met.phi();

    if (isMC_) {

        tthtree->n__met_shift = 12;

        // Pt
        tthtree->met__pt__shift[0]  = met.shiftedPt(pat::MET::JetEnUp);
        tthtree->met__pt__shift[1]  = met.shiftedPt(pat::MET::JetEnDown);
        tthtree->met__pt__shift[2]  = met.shiftedPt(pat::MET::JetResUp);
        tthtree->met__pt__shift[3]  = met.shiftedPt(pat::MET::JetResDown);
        tthtree->met__pt__shift[4]  = met.shiftedPt(pat::MET::MuonEnUp);
        tthtree->met__pt__shift[5]  = met.shiftedPt(pat::MET::MuonEnDown);
        tthtree->met__pt__shift[6]  = met.shiftedPt(pat::MET::ElectronEnUp);
        tthtree->met__pt__shift[7]  = met.shiftedPt(pat::MET::ElectronEnDown);
        tthtree->met__pt__shift[8]  = met.shiftedPt(pat::MET::TauEnUp);
        tthtree->met__pt__shift[9]  = met.shiftedPt(pat::MET::TauEnDown);
        tthtree->met__pt__shift[10] = met.shiftedPt(pat::MET::UnclusteredEnUp);
        tthtree->met__pt__shift[11] = met.shiftedPt(pat::MET::UnclusteredEnDown);

        // Px
        tthtree->met__px__shift[0]  = met.shiftedPx(pat::MET::JetEnUp);
        tthtree->met__px__shift[1]  = met.shiftedPx(pat::MET::JetEnDown);
        tthtree->met__px__shift[2]  = met.shiftedPx(pat::MET::JetResUp);
        tthtree->met__px__shift[3]  = met.shiftedPx(pat::MET::JetResDown);
        tthtree->met__px__shift[4]  = met.shiftedPx(pat::MET::MuonEnUp);
        tthtree->met__px__shift[5]  = met.shiftedPx(pat::MET::MuonEnDown);
        tthtree->met__px__shift[6]  = met.shiftedPx(pat::MET::ElectronEnUp);
        tthtree->met__px__shift[7]  = met.shiftedPx(pat::MET::ElectronEnDown);
        tthtree->met__px__shift[8]  = met.shiftedPx(pat::MET::TauEnUp);
        tthtree->met__px__shift[9]  = met.shiftedPx(pat::MET::TauEnDown);
        tthtree->met__px__shift[10] = met.shiftedPx(pat::MET::UnclusteredEnUp);
        tthtree->met__px__shift[11] = met.shiftedPx(pat::MET::UnclusteredEnDown);

        // Py
        tthtree->met__py__shift[0]  = met.shiftedPy(pat::MET::JetEnUp);
        tthtree->met__py__shift[1]  = met.shiftedPy(pat::MET::JetEnDown);
        tthtree->met__py__shift[2]  = met.shiftedPy(pat::MET::JetResUp);
        tthtree->met__py__shift[3]  = met.shiftedPy(pat::MET::JetResDown);
        tthtree->met__py__shift[4]  = met.shiftedPy(pat::MET::MuonEnUp);
        tthtree->met__py__shift[5]  = met.shiftedPy(pat::MET::MuonEnDown);
        tthtree->met__py__shift[6]  = met.shiftedPy(pat::MET::ElectronEnUp);
        tthtree->met__py__shift[7]  = met.shiftedPy(pat::MET::ElectronEnDown);
        tthtree->met__py__shift[8]  = met.shiftedPy(pat::MET::TauEnUp);
        tthtree->met__py__shift[9]  = met.shiftedPy(pat::MET::TauEnDown);
        tthtree->met__py__shift[10] = met.shiftedPy(pat::MET::UnclusteredEnUp);
        tthtree->met__py__shift[11] = met.shiftedPy(pat::MET::UnclusteredEnDown);

        // Phi
        tthtree->met__phi__shift[0]  = met.shiftedPhi(pat::MET::JetEnUp);
        tthtree->met__phi__shift[1]  = met.shiftedPhi(pat::MET::JetEnDown);
        tthtree->met__phi__shift[2]  = met.shiftedPhi(pat::MET::JetResUp);
        tthtree->met__phi__shift[3]  = met.shiftedPhi(pat::MET::JetResDown);
        tthtree->met__phi__shift[4]  = met.shiftedPhi(pat::MET::MuonEnUp);
        tthtree->met__phi__shift[5]  = met.shiftedPhi(pat::MET::MuonEnDown);
        tthtree->met__phi__shift[6]  = met.shiftedPhi(pat::MET::ElectronEnUp);
        tthtree->met__phi__shift[7]  = met.shiftedPhi(pat::MET::ElectronEnDown);
        tthtree->met__phi__shift[8]  = met.shiftedPhi(pat::MET::TauEnUp);
        tthtree->met__phi__shift[9]  = met.shiftedPhi(pat::MET::TauEnDown);
        tthtree->met__phi__shift[10] = met.shiftedPhi(pat::MET::UnclusteredEnUp);
        tthtree->met__phi__shift[11] = met.shiftedPhi(pat::MET::UnclusteredEnDown);

        tthtree->gen_met__pt  = met.genMET()->pt();
        tthtree->gen_met__phi = met.genMET()->phi();
    }

    //get the LHE gen-level stuff
    //code from LB --> LHE not always available
    if ( isMC_ ) {
        edm::Handle<LHEEventProduct> lhe;
        if( !lheToken_.isUninitialized() )
            iEvent.getByToken(lheToken_, lhe);

        if( lhe.isValid() ) {

            const lhef::HEPEUP hepeup_ = lhe->hepeup();
            const std::vector<lhef::HEPEUP::FiveVector> pup_ = hepeup_.PUP; // px, py, pz, E, M

            double lheHT = 0.0;
            unsigned int lheNj = 0;
            unsigned int countBquarks=0, countCquarks=0, countUDSquarks=0, countGquarks=0, countExtraPartons=0;
            for (unsigned int i=0; i<pup_.size(); ++i) {
                int id=hepeup_.IDUP[i]; //pdgId
                int status = hepeup_.ISTUP[i];
                int idabs=TMath::Abs(id);

                // gluons and quarks
                if(status == 1 && ((idabs == 21) || (idabs > 0 && idabs < 7))) {
                    // first entry is px, second py
                    lheHT += TMath::Sqrt( TMath::Power(hepeup_.PUP[i][0],2) + TMath::Power(hepeup_.PUP[i][1],2) );
                    lheNj++;
                }

                if ( hepeup_.ISTUP[i] >= 0 && status == 1 ) {
                    if (!(hepeup_.MOTHUP[i].first !=1 && hepeup_.MOTHUP[i].second !=2)) {
                        if(idabs==5  ) countBquarks++;
                        if(idabs==4  ) countCquarks++;
                        if(idabs<=3 && idabs>=1 ) countUDSquarks++;
                        if(idabs==21  ) countGquarks++;
                        if(idabs==21 || (idabs>=1 && idabs<=5)) countExtraPartons++;
                    }
                }
            }
            tthtree->lhe__ht = lheHT;
            tthtree->lhe__n_j = lheNj;
            tthtree->lhe__n_b = countBquarks;
            tthtree->lhe__n_c = countCquarks;
            tthtree->lhe__n_l = countUDSquarks;
            tthtree->lhe__n_g = countGquarks;
            tthtree->lhe__n_e = countExtraPartons;
        }
    } // isMC for LHE

    if (isMC_) {
        // Packed particles are all the status 1, so usable to remake jets
        // The navigation from status 1 to pruned is possible (the other direction should be made by hand)
        //Handle<edm::View<pat::PackedGenParticle>> packed;
        //iEvent.getByToken(packedGenToken_, packed);

        vector<const reco::GenParticle*> tops;
        vector<const reco::GenParticle*> antitops;
        
        vector<const reco::GenParticle*> bquarks;
        vector<const reco::GenParticle*> antibquarks;
        
        //find top and antitop
        for (auto& gp : *pruned) {
            //top quarks
            if (gp.pdgId() == 6 && gp.status() == 3) {
                tops.push_back(&gp);
                LogDebug("genparticles") << "top " << CANDPRINT(gp) << " dau1 " << gp.daughter(0) << " dau2 " << gp.daughter(1);
            }
            if (gp.pdgId() == -6 && gp.status() == 3) {
                antitops.push_back(&gp);
                LogDebug("genparticles") << "antitop " << CANDPRINT(gp) << " dau1 " << gp.daughter(0) << " dau2 " << gp.daughter(1);
            }
           
            //b-quarks not from top decay
            if (gp.pdgId() == 5 && gp.status() == 3 && gp.mother(0)!=0 && abs(gp.mother(0)->pdgId()) == 25) {
                bquarks.push_back(&gp);
                LogDebug("genparticles") << "bquark " << CANDPRINT(gp) << " dau1 " << gp.daughter(0) << " dau2 " << gp.daughter(1);
            }
            
            if (gp.pdgId() == -5 && gp.status() == 3 && gp.mother(0)!=0 && abs(gp.mother(0)->pdgId()) == 25) {
                antibquarks.push_back(&gp);
                LogDebug("genparticles") << "antibquark " << CANDPRINT(gp) << " dau1 " << gp.daughter(0) << " dau2 " << gp.daughter(1);
            }

        } //pruned genparticles
        LogDebug("genparticles") << "gensummary top " << tops.size() << " antitop " << antitops.size() << " bquark " <<  bquarks.size() << " antibquarks " << antibquarks.size();

        if (tops.size()==1) {
            const reco::Candidate* dau1 = tops[0]->daughter(0);
            const reco::Candidate* dau2 = tops[0]->daughter(1);
            
            if(dau1==0 || dau2==0 || tops[0]->numberOfDaughters()<2) {
                edm::LogError("genparticles") << "top ndau " << tops[0]->numberOfDaughters() << " dau1 " << dau1 << " dau2 " << dau2 << " null pointer or not enough daugters";
            } else {
                const reco::Candidate* b = 0;
                const reco::Candidate* w = 0;
                if (abs(dau1->pdgId())==5 && abs(dau2->pdgId())==24) {
                    b = dau1;
                    w = dau2;
                }
                if (abs(dau2->pdgId())==5 && abs(dau1->pdgId())==24) {
                    b = dau2;
                    w = dau1;
                }
                if (b==0 or w==0) {
                    edm::LogError("genparticle") << "top could not assign b " << b << " or w " << w;
                    edm::LogWarning("genparticle") << "top daughters " << tops[0]->numberOfDaughters();
                    for (unsigned int i=0;i < tops[0]->numberOfDaughters(); i++) {
                        cerr << " dau " << i << tops[0]->daughter(i) << " " << tops[0]->daughter(i)->pdgId();  
                    }
                    cerr << endl;
                } else {
                    tthtree->gen_t__b__pt = b->pt();
                    tthtree->gen_t__b__eta = b->eta();
                    tthtree->gen_t__b__phi = b->phi();
                    tthtree->gen_t__b__mass = b->mass();
                    
                    if(w->daughter(0)!=0 && w->daughter(1)!=0) { 
                        tthtree->gen_t__w_d1__pt = w->daughter(0)->pt();
                        tthtree->gen_t__w_d1__eta = w->daughter(0)->eta();
                        tthtree->gen_t__w_d1__phi = w->daughter(0)->phi();
                        tthtree->gen_t__w_d1__mass = w->daughter(0)->mass();
                        tthtree->gen_t__w_d1__id = w->daughter(0)->pdgId();
                        tthtree->gen_t__w_d1__status = w->daughter(0)->status();
                        LogDebug("genparticles") << "top w dau1 " << PCANDPRINT(w->daughter(0)); 
                        
                        tthtree->gen_t__w_d2__pt = w->daughter(1)->pt();
                        tthtree->gen_t__w_d2__eta = w->daughter(1)->eta();
                        tthtree->gen_t__w_d2__phi = w->daughter(1)->phi();
                        tthtree->gen_t__w_d2__mass = w->daughter(1)->mass();
                        tthtree->gen_t__w_d2__id = w->daughter(1)->pdgId();
                        tthtree->gen_t__w_d2__status = w->daughter(1)->status();
                        LogDebug("genparticles") << "top w dau2 " << PCANDPRINT(w->daughter(1)); 
                    } else {
                        edm::LogError("genparticles") << "top w dau1 " << w->daughter(0) << " dau2 " << w->daughter(1) << " null pointer!";
                    }
                }
            }
        }
   
        //This is a carbon copy of the above
        if (antitops.size()==1) {
            const reco::Candidate* dau1 = antitops[0]->daughter(0);
            const reco::Candidate* dau2 = antitops[0]->daughter(1);
            
            if(dau1==0 || dau2==0 || antitops[0]->numberOfDaughters()<2) {
                edm::LogError("genparticles") << "antitop ndau " << antitops[0]->numberOfDaughters() << " dau1 " << dau1 << " dau2 " << dau2 << " null pointer or not enough daughters!";
            } else {
                const reco::Candidate* b = 0;
                const reco::Candidate* w = 0;
                if (abs(dau1->pdgId())==5 && abs(dau2->pdgId())==24) {
                    b = dau1;
                    w = dau2;
                }
                if (abs(dau2->pdgId())==5 && abs(dau1->pdgId())==24) {
                    b = dau2;
                    w = dau1;
                }
                if (b==0 or w==0) {
                    edm::LogError("genparticle") << "antitop could not assign b " << b << " or w " << w; 
                    edm::LogWarning("genparticle") << "antitop daughters " << antitops[0]->numberOfDaughters();
                    for (unsigned int i=0;i < antitops[0]->numberOfDaughters(); i++) {
                        cerr << " dau " << i << antitops[0]->daughter(i) << " " << antitops[0]->daughter(i)->pdgId();  
                    }
                } else {
                    tthtree->gen_tbar__b__pt = b->pt();
                    tthtree->gen_tbar__b__eta = b->eta();
                    tthtree->gen_tbar__b__phi = b->phi();
                    tthtree->gen_tbar__b__mass = b->mass();
                    
                    if(w->daughter(0)!=0 && w->daughter(1)!=0) { 
                        tthtree->gen_tbar__w_d1__pt = w->daughter(0)->pt();
                        tthtree->gen_tbar__w_d1__eta = w->daughter(0)->eta();
                        tthtree->gen_tbar__w_d1__phi = w->daughter(0)->phi();
                        tthtree->gen_tbar__w_d1__mass = w->daughter(0)->mass();
                        tthtree->gen_tbar__w_d1__id = w->daughter(0)->pdgId();
                        tthtree->gen_tbar__w_d1__status = w->daughter(0)->status();
                        LogDebug("genparticles") << "antitop w dau1 " << PCANDPRINT(w->daughter(0)); 
                        tthtree->gen_tbar__w_d2__pt = w->daughter(1)->pt();
                        tthtree->gen_tbar__w_d2__eta = w->daughter(1)->eta();
                        tthtree->gen_tbar__w_d2__phi = w->daughter(1)->phi();
                        tthtree->gen_tbar__w_d2__mass = w->daughter(1)->mass();
                        tthtree->gen_tbar__w_d2__id = w->daughter(1)->pdgId();
                        tthtree->gen_tbar__w_d2__status = w->daughter(1)->status();
                        LogDebug("genparticles") << "antitop w dau2 " << PCANDPRINT(w->daughter(1)); 
                    } else {
                        edm::LogError("genparticles") << "antitop w dau1 " << w->daughter(0) << " dau2 " << w->daughter(1) << " null pointer!";
                    }
                }
            }
        }

        if (bquarks.size()==1) {
            tthtree->gen_b__pt = bquarks[0]->pt(); 
            tthtree->gen_b__eta = bquarks[0]->eta(); 
            tthtree->gen_b__phi = bquarks[0]->phi(); 
            tthtree->gen_b__mass = bquarks[0]->mass(); 
            tthtree->gen_b__status = bquarks[0]->status(); 
            tthtree->gen_b__id = bquarks[0]->pdgId(); 
        }
        if (antibquarks.size()==1) {
            tthtree->gen_bbar__pt = antibquarks[0]->pt(); 
            tthtree->gen_bbar__eta = antibquarks[0]->eta(); 
            tthtree->gen_bbar__phi = antibquarks[0]->phi(); 
            tthtree->gen_bbar__mass = antibquarks[0]->mass(); 
            tthtree->gen_bbar__status = antibquarks[0]->status(); 
            tthtree->gen_bbar__id = antibquarks[0]->pdgId(); 
        }
    } // isMC

    //These also index the number of generated lepton/jets
    tthtree->n__lep = n__lep;
    tthtree->n__jet = n__jet;

    sw->Stop();
    tthtree->debug__time1r = sw->RealTime();
    tthtree->debug__time1c = sw->CpuTime();
    LogDebug("time") << "timing " << tthtree->debug__time1r << " " << tthtree->debug__time1c;
    tthtree->tree->Fill();
}

// ------------ method called once each job just before starting event loop  ------------
void
TTHNtupleAnalyzer::beginJob()
{
}

// ------------ method called once each job just after ending the event loop  ------------
void
TTHNtupleAnalyzer::endJob()
{
}

// ------------ method called when starting to processes a run  ------------
/*
void
TTHNtupleAnalyzer::beginRun(edm::Run const&, edm::EventSetup const&)
{
}
*/

// ------------ method called when ending the processing of a run  ------------
/*
void
TTHNtupleAnalyzer::endRun(edm::Run const&, edm::EventSetup const&)
{
}
*/

// ------------ method called when starting to processes a luminosity block  ------------
/*
void
TTHNtupleAnalyzer::beginLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
}
*/

// ------------ method called when ending the processing of a luminosity block  ------------
/*
void
TTHNtupleAnalyzer::endLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
}
*/

// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
void
TTHNtupleAnalyzer::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
    //The following says we do not know what parameters are allowed so do no validation
    // Please change this to state exactly what you do use, even if it is no parameters
    edm::ParameterSetDescription desc;
    desc.setUnknown();
    descriptions.addDefault(desc);
}

//define this as a plug-in
DEFINE_FWK_MODULE(TTHNtupleAnalyzer);
